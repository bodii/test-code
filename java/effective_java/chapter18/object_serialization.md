### 对象序列化(object serialization)
它是Java的一个框架，用来将对象编码成字节流（序列化），并从字节流编码中重新构建对象（反序列化）。一旦对象被序列化后，它的编码就可以从一台正在运行的虚拟机被传递到另一台虚拟机上，或者被存储在磁盘上，供后续序列化时使用。


### 谨慎地实现 Serializable接口
>要想使一个类的实例可被序列化，非常简单，只要在它的声明中加入implements Serializable字样即可。正因为太容易了，所以普遍存在这样一种误解，认为程序员访毫不费力就可以实现序列化。而实际的情形要复杂得多。虽然使一个类可被序列化的直接开销非常低，甚至可以忽略不计，但是为了序列化而付出的长期开销往往是相当高的。

序列化会使类的演变受到限制，这种限制的一个例子与流的唯一标识符(stream unique identifier)有关，通常
称它为序列版本UID(serial version UID)。每个可序列化的类都有一个唯一标识号与它相关联。如果你没有在一个名为serialVersionUID的私有静态final的long域中显式地指定该标识号，系统就会对这个类的结构运用一个加密的散列函数（SHA－1），从而在运行时自动产生该标识号。这个自动产生的值会受到类名称、它所实现的接口的名称，以及所有仅有的和受保护的成员的名称影响。如果你通过任何方式改变了这些信息，比如，增加了一个不是很重要的工具方法，自动产生的序列版本UID也会发生变化。因此，如果你没有声明一个显式的序列版本UID,兼容性将会遭到破坏，在运行时导致InvalidClassException异常。


### 使用Serializable的代价
1. 一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。
2. 它增加了出现Bug和安全漏洞的可能性。
3. 随着类发行新的版本，相关的测试负担也会增加。
4. 接口并不是一个很轻松就可以做出的决定。


>接受默认的序列化形式是一个非常重要的决定，需要从灵活性、性能和正确性等多个角度对这种编码形式进行考虑。一般来讲，只有当自行设计的自定义序列化形式与默认的序列化形式基本相同时，才能接爱默认的序列化形式。


>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。



### 当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点:
1. 它使这个类的导出API永远地束缚在该类的内部表示法上。
2. 它会消耗过多的空间。
3. 它会消耗过多的时间。
4. 它会引起。
  

### 要声明一个序列化版本UID非常简单，只要在你的类中增加：
```java
private static final long serialVersionUIS = randomLongValue;
```