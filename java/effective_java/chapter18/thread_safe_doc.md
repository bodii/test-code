### 线程安全性的文档化
javadoc并没有在它的输出中包含synchronized修饰符，这是因为`在一个方法声明中出现synchronized修饰符，这是个实现细节，并不是导出的API的一部分。`它并不一定表明这个方法是线程安全的。

线程安全性有多种线程安全性级别：
* 不可变的(immutable) -- 这个类的实例是不变的。所以，不需要外部的同步。这样的例子包括String、Long
和BigInteger。
* 无条件的线程安全(unconditionally thread-safe)-- 这个类的实例是可变的，但是这个类有足够的内部同步，所以它的实例可以被并发使用，无须任何外部同步。其例子包括AtomicLong和ConcurrentHashMap。
* 有条件的线程安全(conditionally thread-safe) -- 除了有些方法为进行安全的并发使用而需要外问部同步之外，这种线程安全级别与无条件的线程安全相同。这样的例子包括Collections.synchronized包装返回的集合，它们的迭代器要求外部同步。
* 非线程安全(not thread-sofe)--这个类的实例是可变的。为了并发地使用它们，客户端必须利用自己选择的外
部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap。
* 线程对立的(thread-hostile)--这种类不能安全地被多个线程并发使用，即使所有的方法调用被外部同步包围。线程对立的根源通常在于，没有同步地修改静态数据。没有人会有意编写一个线程对立的类；这种类是因为没有考虑到并发性而产生的后果。当一个类或者方法被发现是线程对立的，一般会得到修正，或者被标注为“不再建议使用”。