#### 散列集
可以快速查找所需要的对象，这就是散列表(hash table)。
散列表为每个对象计算一个整数，称为散列码(hash code)。
> 散列码是由对象的实例域产生一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。

在Java中，散列表用链表数组实现。每个列表被称为`桶(bucket)`。
要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这
个元素的桶的索引。例如，如果某个对象的散列码为76268,并且有128个桶，对象应该保存在第108号
桶中976268除以128余108)。或许会很幸运，在这个桶中没有其他元素，此时将元素直接插入到桶中
就可以了。
当然，有时候遇到被占满的情况，这也是不可避免的。这种现象被称为`散列冲突(hash collision)`。
这时，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。
如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。

标准类库使用的桶数是2的幂，默认值为16。
当然，并不是总能够知道需要存储多少个元素的，也有可能最初的估计过低。
如果散列表太满，就需要`再散列(rehashed)`。
如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃
原来的表。`装填因子(load factor)`决定何时对散列表进行再散列。例如，如果装填因子为0.75(默
认值),而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数
应用程序来说，装填因子为0.75是比较合理的。

散列表可以用于实现几个重要的数据结构。其中最简单的是set类型。set是没有重复元素的元素集合。
set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。

Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains
方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而
不必查看集合中的所有元素。

只有不关心集合中元素的顺序时才应该使用HashSet。


