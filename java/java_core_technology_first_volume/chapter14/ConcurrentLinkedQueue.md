#### 线程安全的集合
如果多线程要并发地修改一个数据结构，例如散列表，那么很容易会破坏这个数据结构。
例如，一个线程可能要开始向表中插入一个新元素。假定在调整散列表各个桶之间的链接关系的过程中，被剥夺了控制权。如果另一个线程也开始遍历同一个链表，可能使用无效的链接并造成混乱，会抛出异常或者陷入死循环。
可以通过提供锁来保护共享数据结构，但是选择线程安全的实现作为替代可能更容易些。阻塞队列就是线程安全的集合。

#### 高效的映射、集和队列
java.util.concurrent包提供了映射、有序集和队列的高效实现:
ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentListedQueue。
这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。
与大多数集合不同，size方法不必在常量时间内操作。确定这样的集合当前的大小通常需要遍历。

> 有些应用使用庞大的并发散列映射，这些映射太过庞大，以至于无法用size方法得到它的大小，因为这个方法只能返回int。对于一个包含超过20亿条目的映射该如何处理？Java SE 8 引入了一个mappingCount方法可以把大小作为long返回。

集合返回`弱一致性(weakly consistent)`的迭代器。这意味着迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会将同一个值返回两次，也不会抛出ConcurrentModificationException异常。

并发的散列映射表，可高效地支持大量的读者和一定数量的写者。默认情况下，假定可以有多达16个写者线程同时执行。可以有更多的写者线程。可以有更多的写者线程，但是，如果同一时间多于16个，其他线程将暂时被阻塞。可以指定更大数目的构造器，然而，恐怕没有这种必要。

> 散列映射将有相同散列码的所有条目放在同一个“桶”中。有些应用使用的散列函数不当，以至于所有条目最后都放在很少的桶中，这会严重降低性能。即使是一般意义上还算合理的散列函数，如String类的散列函数，也可能存在问题。例如，攻击者可能会制造大量有相同散列值的字符串，让程序速度减慢。在Java SE8中，并发散列映射将桶组织为树，而不是列表，键类型实现了Comparable,从而可以保证性能为O(log(n))。