#### 线程状态
线程可以有如下6种状态:
* New (新创建)
* Runnable (可运行)
* Blocked (被阻塞)
* Waiting (等待)
* Timed waiting (计时等待)
* Termainated (被终止)
	

#### 新创建线程
当用new 操作符创建一个新线程时，如new Thread(r),该线程还没有开始运行。这意味着它的状态是
new。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基
础工作要做。


#### 可运行线程
一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取
决于操作系统给线程提供运行的时间。(Java的规范说明没有将它作为一个单独状态。一个正在运行中
的线程仍然处于可运行状态。)
一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程
获得运行机会。线程调试的细节依赖于操作系统提供的服务。抢占式调试系统给每一个可运行线程一个
时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择
下一个线程时，操作系统考虑线程的优先级。
现在所有的桌面以及服务器操作系统都使用抢占式调试。但是，像手机这样的小型设备可能使用协作式
调试。在这样的设备中，一个线程只有在调用yield方法、或者被阻塞或等待时，线程才失去控制权。
在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程
的数目多于处理器的数目，调试器依然采用时间片机制。
记住，在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行(这就是为什么将这个状态称为
可运行而不是运行)。


#### 被阻塞线程和等待线程
当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调试
器重新激活它。细节取决于它是怎样达到非活动状态的。
* 当一个线程试图获取一个内部的对象锁(而不是java.util.concurrent库中的锁),而该锁被其他线程
持有，则该线程进入`阻塞状态`。当所有其他线程释放该锁，并且线程调试器允许本线程持有它的时候
，该线程将变成非阻塞状态。

* 当线程等待另一个线程通知调试器一个条件时，它自己进入等待状态。在调用Object.wait方法或
Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。
实际上，被阻塞状态与等待状态是有很大不同。

* 有几个方法有一个超时参数。调用它们导致线程进入计时等待(timed waiting)状态。这一状态将一
直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep和Object.wait、
Thread.join、Lock.tryLock以及Condition.await的计时版。

当一个线程被阻塞或等待时(或终止时),另一个线程被调试为运行状态。当一个线程被重新激活(例如，
因为超时期满或成功地获得一个锁),调试器检查它是否具有比当前运行线程更高的优先线。如果是这
样，调试器从当前运行线程中挑选一个，剥夺其运行权，选择一个新的线程运行。


#### 被终止的线程
线程因如下两个原因之一而被终止:
* 因为run方法正常退出而自然死亡。
* 因为一个没有捕获的异常终止了run方法而意外死亡。
特别是，可以调用线程的stop方法杀死一个线程。该方法抛出ThreadDeath错误对象，由此杀死线程。
但是，stop方法已过时，不要在自己的代码中调用这个方法。


#### java.lang.Thread
* void join() 
	等待终止指定的线程。
* void join(long millis)
	等待指定的线程死亡或者经过指定的毫秒数。
* Thread.State getState()
	得到这一线程的状态; NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING或TERMINATED之一。
* void stop()
	停止该线程。这一方法已过时。
* void suspend()
	暂停这一线程的执行。这一方法已过时。
* void resume()
	恢复线程。这一方法仅仅在调用suspend()之后调用。这一方法已过时。
