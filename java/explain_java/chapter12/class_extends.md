### 类的派生
只可以在构造函数的开头调用super()。
调用超类的构造函数的super()与调用同一个类中其他构造函数的this()类似。另外，一个构造
函数中不可以同时调用super和this。

```java
Point3D(int x, int y, int z) { // 编译器插入 super(); this.x = x; this.y = y;this.z = z; }
```
在不显式调用super()的构造函数的开头行中，会自动插入超类中"不接收参数的构造函数"的调用super()。
如果一个构造函数都没有定义，则会自动定义一个只调用super()的默认构造函数。

> 在未定义构造函数的类中，会自动定义如下形式的默认构造函数。
```java
X() { super(); }
```

虽然超类的构造函数不可以被继承，但“不接收参数的构造函数”可以被间接继承。

> 超类的成员可以通过"super.成员名"进行访问。

当类中未定义构造函数时，其超类中必须持有“不接收参数的构造函数”。


### 区分
超类			派生源的类（父类）
子类			通过派生创建的类（孩子）
上位类			包含父新在内的祖先类（父亲、祖父、曾祖父...)
下位类			包含孩子在内的子孙类（孩子、孙子、曾孙...)
间接上位类		除去父亲之外的祖先类（祖父、曾祖父...)
间接下位类		除去孩子之外的子孙类（孙子、曾孙...)


### 派生
Java不支持从多个类进行派生的多重继承。
在多重继承中，当不同超类中包含同名的字段或方法时，内部处理会变得极其复杂。不支持多重继承是
Java崇尚简洁的一种表现。

### 类层次图中的箭头方向
类层次图中的箭头是“子类-->超类”，即“子-->父”。
```
class Derived extends Base { } 
```
声明中“extends Base”是声明“我让Base作为父亲”。
超类端无法声明“将这个类作为我的孩子”，而子类端可以声明“将这个类作为我的父亲”，因此箭头方向是
“子类-->超类”


### Object类
不执行显式派生声明的类都是Object类的子类。Java中的所有类都是Object类的下位类。
另外，Object类有时也被称为“老大类”。


### 继承
继承的一个好处就是可以进行`增量编程(incremental programming)`,即对已有的程序只进行最低程度的添加、
修改，就呆以实现一个新的程序。这可以提高程序的开发效率和维护性。


### is-A关系和实例的引用
TimeAccount是Account的孩子，属于Account家（Account家族），这种关系称为`is-A关系`
这种关系反过来就不成立了，Account并不是TimeAccount的一种。另外，is-A关系也称为kind-of-A关系。


对于类类型的参数，除了可以传递该类类型的实例的引用之外，还可以传递该类的下位类类型的实例的引用。


### 多态
类类型的变量由于派生关系，可以引用各种类类型实例，这被称为多态性，即多态(polymorphism)。
poly是“多的“， morph是"形态"的意思。多态也被称为“多样性“同名异型" "多态性"等。

在编译时确定要调用的方法，这种调用结构称为`静态联编(static binding)`或前期联编(early binding).
在运行时确定要调用的方法，这种调用结构被称为`动态联编(dynamic binding)` 或后期联编(late binding)。
binding也可翻译为绑定。例如，动态联编也被称为动态绑定或后期绑定。
