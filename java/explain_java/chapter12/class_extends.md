### 类的派生
只可以在构造函数的开头调用super()。
调用超类的构造函数的super()与调用同一个类中其他构造函数的this()类似。另外，一个构造
函数中不可以同时调用super和this。

```java
Point3D(int x, int y, int z) { // 编译器插入 super(); this.x = x; this.y = y;this.z = z; }
```
在不显式调用super()的构造函数的开头行中，会自动插入超类中"不接收参数的构造函数"的调用super()。
如果一个构造函数都没有定义，则会自动定义一个只调用super()的默认构造函数。

> 在未定义构造函数的类中，会自动定义如下形式的默认构造函数。
```java
X() { super(); }
```

虽然超类的构造函数不可以被继承，但“不接收参数的构造函数”可以被间接继承。

> 超类的成员可以通过"super.成员名"进行访问。

当类中未定义构造函数时，其超类中必须持有“不接收参数的构造函数”。


### 区分
超类			派生源的类（父类）
子类			通过派生创建的类（孩子）
上位类			包含父新在内的祖先类（父亲、祖父、曾祖父...)
下位类			包含孩子在内的子孙类（孩子、孙子、曾孙...)
间接上位类		除去父亲之外的祖先类（祖父、曾祖父...)
间接下位类		除去孩子之外的子孙类（孙子、曾孙...)


### 派生
Java不支持从多个类进行派生的多重继承。
在多重继承中，当不同超类中包含同名的字段或方法时，内部处理会变得极其复杂。不支持多重继承是
Java崇尚简洁的一种表现。

### 类层次图中的箭头方向
类层次图中的箭头是“子类-->超类”，即“子-->父”。
```
class Derived extends Base { } 
```
声明中“extends Base”是声明“我让Base作为父亲”。
超类端无法声明“将这个类作为我的孩子”，而子类端可以声明“将这个类作为我的父亲”，因此箭头方向是
“子类-->超类”


### Object类
不执行显式派生声明的类都是Object类的子类。Java中的所有类都是Object类的下位类。
另外，Object类有时也被称为“老大类”。


### 继承
继承的一个好处就是可以进行`增量编程(incremental programming)`,即对已有的程序只进行最低程度的添加、
修改，就呆以实现一个新的程序。这可以提高程序的开发效率和维护性。


### is-A关系和实例的引用
TimeAccount是Account的孩子，属于Account家（Account家族），这种关系称为`is-A关系`
这种关系反过来就不成立了，Account并不是TimeAccount的一种。另外，is-A关系也称为kind-of-A关系。


对于类类型的参数，除了可以传递该类类型的实例的引用之外，还可以传递该类的下位类类型的实例的引用。


### 多态
类类型的变量由于派生关系，可以引用各种类类型实例，这被称为多态性，即多态(polymorphism)。
poly是“多的“， morph是"形态"的意思。多态也被称为“多样性“同名异型" "多态性"等。

在编译时确定要调用的方法，这种调用结构称为`静态联编(static binding)`或前期联编(early binding).
在运行时确定要调用的方法，这种调用结构被称为`动态联编(dynamic binding)` 或后期联编(late binding)。
binding也可翻译为绑定。例如，动态联编也被称为动态绑定或后期绑定。


### 引用类型的转型
超类类型的变量可以引用子类的实例，这种类型转换称为`引用类型的放大转换(widening reference conversion)`
或向上类型转换(up cast)
```java
Pet p = (Pet)new RobetPet("R2D2", "卢克");   // 显式转换
```
而子类类型的变量不可以引用超类的实例。不过，显示使用造型运算符进行类型的转换。
```java
RobotPet r1 = new Pet("Kurt", "艾一");   // err
RobotPet r2 = (RobotPet)new Pet("Kurt", "艾一"); // ok
```
这里执行的类型转换称为`引用类型的缩小转换(narrowing reference conversion)` 或向
下类型转换(down cast).

引用类型的放大/缩小转换是Java的语法术语，而向上/向下类型转换则是一般的编程术语。
```java
r2.work(0);   // err
```
原则上应该避免错误执行向下类型转换，使下位类类型的变量引用上位类类型的实例。


### instanceof运符符
> 类类型的变量名 instanceof 类名
如果变量x是可以默认转换为类型t的下位类，则结果为true, 否则为false;


### @Override注解
```java
class RobotPet {
	// -- 中略
	@Override public void introduction() {
		System.out.println("我是机器人。名字是" + getName() + "。");
		System.out.println("我的主人是" + getMasterName() + "。");
	}
}
```
这个注释给人类和编译器传达了下述内容：
> 接下来声明的方法是重写上位类的方法，而不是本类中新添加的方法。
当这个方法超类不中不存在时，编译器中会发生错误。

> 当方法重写上位类中的方法时，最好在声明中加上@Override注释。
annotation 是"注释"或"注释"的意思。


### ＠Deprecated注解
在不断改进类或方法的过程中，有时会出现"创建了更好的类""由于类内部的规格修改，该方法
不能再使用了"等情况，这时就可以使用@Deprecated注释。
在不推荐使用的类或方法的前面加上@Deprecated，这样一来，使用它们的程序在编译时就会发出
警告.
