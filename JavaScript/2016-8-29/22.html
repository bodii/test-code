<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>instanceof 操作符</title>
</head>
<body>
	<script type="text/javascript">
		'use strict'

		 // 创建对象
		 Object.prototype.create = function () {
		 	var object = this;
		 	if (object.construct != undefined)
		 		object.construct.apply(object, arguments);
		 	return object;
		 };

		 // 继承
		 Object.prototype.extend = function (properties) {
		 	var result = this;
		 	forEachIn(properties, function (name, value) {
		 		result[name] = value;
		 	});
		 	return result;
		 };

		 function forEachIn (object, action) {
		 	for (let name in object) {
		 		if (Object.prototype.propertyIsEnumerable.call(object, name))
		 			action(name, object[name])
		 	}
		 }

		 var Item = {
		 	construct: function (name) {
		 		this.name = name;
		 	},
		 	inspect: function () {
		 		console.log('it is ', this.name, '.');
		 	},
		 	kick: function () {
		 		console.log('klunk!');
		 	},
		 	take: function () {
		 		console.log('you cannot left ', this.name, '.');
		 	}
		 };

		 var SmallItme = Item.extend({
		 	kick: function () {
		 		console.log(this.name, ' flies across the room.');
		 	},
		 	take: function () {
		 		console.log('you take', this.name, '.');
		 	}
		 });

		 var pencil = SmallItme.create('the red pencil');


		 		/**
		 * instanceof 
		 * 该操作符可用于确定一个对象是否基于指定的原型。
		 *
		 * $ 如查没有使用常规的构造函数， 使用该操作符就变得很笨拙 ----
		 * 该操作符需要一个构造函数作为其第二个参数，但是我们只有原型。一个
		 * 和clone函数类似的技巧可用于解决这一问题：使用“伪造”构造函数，然后
		 * 将instanceof应用到上面。
		 */
		 
		 Object.prototype.isA = function (prototype) {
		 	function DummyConstructor() {}
		 	DummyConstructor.prototype = prototype;
		 	return this instanceof DummyConstructor;
		 }

		 console.log(pencil.isA(Item));
	</script>	
</body>
</html>