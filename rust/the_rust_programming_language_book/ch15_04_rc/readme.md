### Rc<T>引用计数智能指针
有些情况单个值可能会有多个所有者。
例如，在图数据结构中，多个边可能指向相同的节点，而这个节点从概念上讲为所有指向的它的边所拥有。节点直到没有任何边指向它之前都不应该被清理。

为了启用多所有权，Rust有一个叫做Rc<T>的类型。其名称为`引用计数(reference counting)`的缩写。
引用计数意味着记录一个值引用来的数量来知晓这个值是否仍被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。

Rc<T>用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。

> 注意Rc<T> 只能用于单线程场景

### 使用Rc<T>共享数据
需要使用use语句将Rc<T>引入作用域，因为它不在prelude中。

Rc::clone的实现并不像在部分类型的clone实现那样对所有数据时行深拷贝。
Rc::clone只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间。
通过使用Rc::clone进行引用计数，可以明显的区别深拷贝类的克隆和增加引用计数类的克隆。

### 克隆Rc<T>会增加引用计数
在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用`Rc::strong_count`函数获得。这个函数叫做strong_count而不是count是因为Rc<T>也有weak_count;

每次调用clone，计数会增加1。
当离开作用域时，计数减1。
在main的结尾离开作用域时，些处计数会是0，同时Rc<T>被完全清理。

使用Rc<T>允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。

通过不可变引用，Rc<T>允许在程序的多个部分之间只读地共享数据。如果Rc<T>也允许多个可变引用，则会违反借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。
内部可变性模式和RefCell<T>类型，它可以与Rc<T>结合使用来处理不可变性的限制。
