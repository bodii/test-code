### 使用Box<T>指向堆上的数据
box允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。
除了数据被储存在堆上而不是栈上之外，box没有性能损失。不过也没有很多额外的功能。它们多用于如下场景:
* 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
* 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
* 当希望拥有一个值并只关心它的类型是否实现了特定trait而不是其具体类型的时候

### 使用Box<T>在堆上储存数据
使用box在堆上储存一个i32:
文件名：src/main.rs
```Rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```
这里定义了变量了，其值是一个指向被分配在堆上的值5的Box。

### Box允许创建递归类型
Rust需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是`递归类型(recursive type)`，其值的一部分可以是相同类型的另一个值。这种值的嵌套理论上可以无限的进行下去，所以Rust不知道递归类型需要多少空间。不过box有一个已知的大小，所以通过在循环类型定义中插入box，就可以创建递归类型了。


### 使用Box<T>给递归类型一个已知的大小
Rust无法计算出要为定义为递归的类型分配多少空间
因为Box<T>是一个指针，总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变。
这意味着可以将Box放入Cons成员中而不是直接存放另一个List值。Box会指向另一个位于堆上的List值，而不是存放在Cons成员中。

box只提供了间接存储和堆分配。

Box<T>类型是一个智能指针，因为它实现了Deref trait，它允许Box<T>值被当作引用对待。当Box<T>值离开作用域时，由于Box<T>类型Drop trait的实现，box所指向的堆数据也会被清除
