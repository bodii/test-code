### 共享状态并发
在某种程度上，任何编程语言中的通道都类似于单所有权，因为一旦将一个值传递到通道中，将无法再使用这个值。
共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。

### 互斥器一次只允许一个线程访问数据
**互斥器(mutex)** 是`mutual exclusion`的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的`锁(lock)`来表明其希望访问数据。
**锁**是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，描述互斥器通过锁系统**保护(guarding)**其数据。

互斥器以难以使用著称：
1. 在使用数据之前尝试获取锁。
2. 处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。

### Mutex<T>的API
使用关联函数`new`来创建一个Mutex<T>。使用lock方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。

如果另一个线程拥有锁，并且那个线程panic了，则lock调用会失败。
在这种情况下，没人能够再获取锁，所以这里选择unwrap并在遇到这种情况时使线程panic。

一旦获取了锁，就可以将返回值视为一个其内部数据的可变引用了。

Mutex<T>是一个智能指针。更准确的说，lock调用返回一个叫做MutexGuard的智能指针。这个智能指针实现了Deref来指向其内部数据；其也提供了一个Drop实现当MutexGuard离开作用域时自动释放锁。

### 在线程间共享Mutex<T>

### 原子引用计数Arc<T>
Arc<T>是一个类似Rc<T>并可以安全的用于并发环境的类型。
字母`a`代表**原子性(atomic)**，这是一个**原子引用计数**(atomically reference counted)类型。
`std::sync::atomic`: 原子性类型工作起来类似原始类型，不过可以安全的在线程间共享。

### RefCell<T>/Rc<T>与Mutex<T>/Arc<T>的相似性
Mutex<T>提供了内部可变性，就像Cell系列类型那样。
RefCell<T>可以改变Rc<T>中的内容那样，同样的可以使用Mutex<T>来改变Arc<T>中的内容。
使用Rc<T>有造成引用循环的风险，这时两个Rc<T>值相互引用，造成内存泄漏。同理，Mutex<T>也有造成死锁(deadlock)的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成相互等待。
