### 所有权(ownership)
- 一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存
- 在另一些语言中，程序员必须亲自分配和释放内存。
- Rust：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查，如果
违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序。

> 当代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。
* 跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。
> 所有权的主要目的就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。

### 所有权规则
1. Rust中的每一个值都有一个`所有者(owner)`。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者(变量)离开作用域，这个值将被丢弃。

### 变量作用域
作用域是一个项(item)在程序中有效的范围。
```Rust
let s = "hello";
```
变量`s`绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前`作用域`结束时都是有效的。
注释标明变量`s`在所处是有效的：
```Rust
{                   // s 在这里无效，它尚未声明
  let s = "hello";  // 从此处起,s是有效的
}                   // 此作用域已结束，s不再有效
```

### String类型
```Rust
let s = String::from("hello"); 
```
这两个冒号::是运算符，允许将特定的from函数置于String类型的命令空间(namespace)下，而不需要使用类似string_from这样的名字。
可以修改此类字符串:
```Rust
let mut s = String::from("hello"); 
s.push_str(", world!");
println!("{}", s);
```

### 内存与分配
对于String类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：
* 必须在运行时向内存分配器(memory allocator) 请求内存。
* 需要一个当我们处理完String时将内存返回给分配器的方法。

Rust采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。
```Rust
{
  let s = String::from("hello"); // 从此处起,s是有效的
  // 使用s
} // 此作用域已经结束
  // s 不再有效
```

这是一个将String需要的内存返回给分配器的很自然的位置；当s离开作用域的时候。当变量离开作用域，Rust为我们调用一个特殊的函数。这个函数叫做`drop`,在这里String的作者可以放置释放内存的代码。Rust在结尾的}处自动调用drop。

### 变更与数据交互的方式（一）：移动
为了确保内存安全，在let s2 = s1; 之后，Rust认为s1不再有效，因此Rust不需要在s1离开作用域后清理任何东西。
```Rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```
你会得到一个错误，因为Rust禁止使用无效的引用。
在其他语言中术语`浅拷贝(shollow copy)`和`深拷贝(deep copy)`,那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。Rust同时使第一个变量无效，这个操作被称为`移动(move)`.

Rust永远不会自动创建数据的"深拷贝"。因为，任何自动的复制可以被认为对运行时性能影响较小。

### 变量和数据交互的方式(二): 克隆
如果确实需要深度复制String中堆上的数据，而不仅仅是栈上的数据，可以使用`clone`通用函数。
```Rust
let s1 = String::from("hello");
let s2 = s1.clone();

println("s1 = {}, s2 = {}", s1, s2);
```
当出现clone调用时，一些特定的代码被执行而且这些代码可能相当消耗资源。
### 只有在栈上的数据: 拷贝

### 所有权和函数
```Rust
fn main() {
  let s = String::from("hello");
  takes_ownership(s);

  let x = 5;
  makes_copy(x);
}

fn takes_ownership(some_string: String) {
  println!("{}", some_string);
}

fn makes_copy(some_integer: i32) {
  println!("{}", some_integer);
}
```
如果我们尝试调用takes_ownership后使用s, Rust会抛出编译错误。
