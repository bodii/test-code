### 生命周期与引用有效性
Rust中的每一个引用都有其`生命周期(lifetime)`,也就是引用保持有效的作用域。
大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。


### 生命周期避免了悬垂引用
生命周期的主要目标是避免悬垂引用，它会导致程序引用了非预期引用的数据。
例，它有一个外部作用域和一个内部作用域：
```Rust
{
    let r; // 外部作用域
    { // 内部作用域
        let x = 5;
        r = &x;
    } // 离开内部作用域

    println!("r: {}", r);
}
```
作用域越大我们就说它“存在的越久”。

### 借用检查器
Rust编译器有一个`借用检查器(borrow checker)`，它比较作用域来确保所有的借用都是有效的。

### 生命周期标注语法
生命周期标注并不改变任何引用的生命周期的长短。与当函数签名中指定了泛型类型参数后就可以授受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。生命周期标注描述了多个引用生命周期相互的关系，而不影响其生命周期。

生命周期标注有着一个不太不常见的语法： 生命周期参数名称必须以撇号(')开头，其名称通常全是小写，类似于泛型其名称非常短。'a 是大多数人默认使用的名称。生命周期参数标注位于引用的&之后，并有一个空格来将引用类型与生命周期标注分隔开。

这里有一些例子： 有一个没有生命周期参数的i32的引用，一个有叫做'a的生命周期参数的i32的引用，和一个生命周期也是'a的i32的可变引用：
```Rust
&i32   // 引用
&'a i32  // 带有显式生命周期的引用
&’a mut i32  // 带有显式生命周期的可变引用
```
单个生命周期标注本身没有多少意义，因为生命周期标注告诉Rust多个引用的泛型生命周期参数如何相互联系的。例如如果函数有一个生命周期'a的i32的引用的参数first。还有另一个同样是生命周期'a的i32的引用的参数second。这两个生命周期标注意味着引用first和second必须与这泛型生命周期存在得一样久。

### 函数签名中的生命周期标注
就像泛型类型参数，泛型生命周期参数需要声明在函数名和参数列表间的尖括号中。
```Rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  if x.len() > y.len() {
    x
  } else {
    y
  }
}
```
现在函数签名表明对于某些生命周期'a，函数会获取两个参数，他们都是与生命周期'a存在的一样长的字符串slice。函数会返回一个同样也与生命周期'a存在的一样长的字符串slice。它的实际含义是longest函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致。这就是我们告诉Rust需要其保证的约束条件。
记住通过在函数签名中指定生命周期参数时，我们并没有改变作用任何输入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意longest函数并不需要知道x和y具体会存在多久，而只需要知道有某个可以被'a替代的作用域将会满足这个签名。

当在函数中使用生命周期标注时，这些标注出现在函数签名中，而不存在于函数体中的任何代码中。这是因为Rust能够分析函数中代码而不需要任何协助，不过当函数引用或被函数之外的代码引用时，让Rust自身分析出参数或返回值的生命周期几乎是不可能的。这些生命周期在每次函数被调用时都可能不同。这也就是为什么我们需要手动标记生命周期。

当具体的引用被传递给longest时，被'a所替代的具体生命周期是x的作用域与y的作用域相重叠的那一部分。换一种说法就是泛型生命周期'a的具体生命周期等同于x和y的生命周期中较小的那一个。因为我们用相同的生命周期参数'a标注了返回的引用值，所以返回的引用值就能保证在x和y中较短的那个生命周期结束之前保持有效。

### 深入理解生命周期
指定生命周期参数的正确方式依赖函数实现的具体功能。
例如，如果将longest函数的实现修改为总是返回第一个参数而不是最长的字符串slice，就不需要为参数y指定一个生命周期。
```Rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
  x
}
```
在这个例子中，为参数x和返回值指定了生命周期参数'a，不过没有为参数y指定，因为y的生命周期与参数x和返回值的生命周期没有任何关系。

> 当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用`没有`指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。


### 结构体定义中的生命周期标注
定义包含引用的结构体，不过这需要为结构体定义中的每一个引用添加生命周期标注:

### 生命周期省略(lifetime Elision)
每一个引用都有一个生命周期，需要为那些使用了引用的函数或结构体指定生命周期。
函数没有生命周期标注却能编译是由于一些历史原因：在早期版本(pre-1.0)的Rust中。
> 每一个引用都必须有明确的生命周期。

被编码进Rust引用分析的模式被称为`生命周期省略规则(lifetime elision rules)`。这并不是需要开发者遵守的规则； 这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。

省略规则并不提供完整的推断：如果Rust在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话，它不会猜测剩余引用的生命周期应该是什么。在这种情况，编译器会给出一个错误，这可以通过增加对应引用之间相联系的生命周期标注来解决。

函数或方法的参数的生命周期被称为`输入生命周期(input lifetime)`，而返回值的生命周期被称为`输出生命周期(output lifetime)`。

编译器采用三条规则来判断引用何时不需要明确的标注。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于fn定义，以及impl块。

1. 第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数： `fn foo<'a>(x: &'a i32)`，有两个引用参数的函数有两个不同的生命周期参数，`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`, 依此类推。

2. 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：`fn foo<'a>(x: &’a i32) -> &'a i32`。

3. 第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是&self或&mut self, 说明是个对象的方法(method)，那么所有输出生命周期参数被赋予self的生命周期。

### 方法定义中的生命周期标注
impl块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期标注。
```Rust
impl<'a> ImportantExcerpt<'a> {
  fn level(&self) -> i32 {
    3
  }
}
```
impl之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注self引用的生命周期。

这里是一个适用于第三条生命周期省略规则的例子：
```Rust
impl<'a> ImportantExcerpt<a'> {
  fn announce_and_return_part(&self, announcement: &str) -> &str {
    println!("Attention please: {}", announcement);
    self.part
  }
}
```
这里有两个输入生命周期，所以Rust应用第一条生命周期省略规则并给予&self和announcement他们各自的生命周期。接着，因为其中一个参数是&self，返回值类型被赋予了&self的生命周期，这样所有的生命周期都被计算出来了。

### 静态生命周期
这里有一种特殊的生命周期：'static，其生命周期能够存活于整个程序期间。所有的字符串字面量都拥有'static生命周期，我们也可以选择像下面这样标注出来：
```Rust
let s: &'static str = "I have a static lifetime";
```

### 结合泛型参数、trait bounds和生命周期
