### 使用消息传递在线程间传送数据
一个日益流行的确保安全并发的方式是`消息传递(message passing)`, 这里线程或actor通过发送包含数据的消息来相互沟通。

Rust中一个实现消息传递并发的主要工具是`通道(channel)`，Rust标准库提供了其实现的编程概念。
> 编程中的通道有两部分组成，一个`发送者(transmitter)`和一个`接收者(receiver)`。发送者或接收者任一被丢弃时可以认为通道被`关闭(closed)`了。
```Rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```
这里使用mpsc::channel 函数创建一个新的通道；mpsc是`多个生产者，单个消费者(multiple producer, single consumer)`的缩写。
Rust标准库实现通道的方式意味着一个通道可以有多个产生值的`发送(sending)`端，但只能有一个消费这些值的`接收(receiving)`端。

mpsc::channel函数返回一个元组：第一个元素是发送端，而第二个元素是接收端。
由于历史原因，`tx`和`rx`通常作为`发送者(transmitter)`和`接收者(receiver)`的缩写

通道的接收端有两个有用的方法：recv和try_recv。
`recv(receive)`这个方法会阻塞主线程执行直到从通道中接收一个值。一旦发送了一个值，recv会在一个`Result<T, E>`中返回它。当通道发送端关闭，recv会返回一个错误表明不会再有新的值到来了。

`try_recv`不会阻塞，相反它立刻返回一个Result<T, E>：Ok值包含可用的信息，而Err值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用try_recv很有用：可以编写一个循环来频繁调用try_recv，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。

### 通道与所有权转移
防止并发编程中的错误是在Rust程序中考虑所有权的一大优势。
> 一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前将其修改或丢弃。

### 发送多个值并观察接收者的等待
将`rx`当作一个迭代器,当通道被关闭时，迭代器也将结束

### 通过克隆发送者来创建多个生产者
