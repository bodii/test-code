#### 明示常量： #define
ANSI和后来的标准都允许#号前面有空格或制表符，而且还允许在#和指令的其余部分
之间有空格。但是旧版本的C要求指令从一行最左边开始，而且#和指令其余部分之间
不能有空格。
指令可以出现在源文件的任何地方，其定义从指令出现的地方到该文件末尾有效。我
们大量使用#define指令来定义明示常量(manifest constant)(也叫做符号常量)，但
该指令还有许多其他用途。

预处理器指令从#开始运行，到后面的第1个换行符为止。也就是说，指令的长度仅限
一行。在预处理开始前，编译器会把多行物理行处理为一行逻辑行。


每行#define(逻辑行)都由3部分组成。

* 第1部分是#define指令本身。
* 第2部分是选定的缩写，也称为宏。有些宏代表值，这些宏被称为类`对象宏(object-like
 macro)`.C语言还有`类函数宏(function-like macro)`.`宏的名称中不允许有空格，
而且必须遵循C变量的命名规则:只能使用字符、数字和下划线(_)字符，而且首字符不
能是数字`。
* 第3部分(指令行的其余部分)称为替换列表或替换体。
一旦预处理器在程序中找到宏的示实例后，就会用替换体代替该宏。
> 从宏变成最终替换文本的过程称为`宏展开(macro expansion)`。


#### const关键字
用const可以创建在程序运行过程中不能改变的变量，可具有文件作用域或块作用域。
另一面，宏常量可用于指定标准数组的大小和const变量的初始值。
```c
#define LIMIT 20
const LIM = 50;
static int data1[LIMIT];   // 有效
static int data2[LIM];     // 无效
const int LIM2 = 2 * LIMIT;   // 有效
const int LIM3 = 2 * LIM;     // 无效
```
在C中，非自动数组的大小应该是整型常量表达式，这意味着表示数组大小的必须是
整型的组合、枚举常量和sizeof表达式，不包括const声明的值。


#### 记号
从技术角度来看，可以把宏的替换体看作是记号(token)型字符串，而不是字符型字
符串。C预处理器记号是宏定义的替换体中单独的“词”。用空白把这些词分开。
```c
#define FOUR 2*2
```
该宏定义有一个记号： 2*2序列。
```c
#define SIX 2 * 3
```
有3个记号： 2、*、 3
替换体中有多个空格时，字符型字符串和记号型字符串的处理方式不同。
解释为字符型字符串，把空格视为替换体的一部分;
解释为记号型字符串，把空格视为替换体中各记号的分隔符。在实际应用中，一些
C编译器把宏替换体视为字符串而不是记号。
C编译器处理记号的方式比预处理器复杂。由于编译器理解C语言的规则，所以不要
求代码中用空格来分隔记号。
例如，C编译器可以把2*2直接视为3个记号，因为它可以识别2是常量，*是运算符。


#### 重定义常量
```c
#define SIX 2 * 3
#define SIX 2 * 3
```
这两条定义都有3个相同的记号，额外的空格不算替换体的一部分。而下面的定义
则与上面的两条宏定义不同：
```c
#define SIX 2*3
```
这条宏定义中只有一个记号，因此与前面两条定义不同。如果需要重定义宏，使用
`#undef`指令.


#### 在#define中使用参数
在#define中使用参数可以创建外形和作用与函数类似的`类函数宏`.
```c
#define MEAN(x, y) (((x)+(y))/2)
```
示例：
```c
#define SQUARE(X) X*X
// 在程序中可以这样用:
z = SQUARE(2);
```
这里，SQUARE是宏标识符，SQUARE(X)中的X是宏参数，X*X是替换列表。
宏定义中的X由宏调用中的符号代替.因此，SQUARE(2)替换为2*2,X实际上起到参数
的作用。
宏参数与函数参数不完全相同。


#### 用宏参数创建字符串: #运算符
```c
#define PSQR(X) printf("The square of X is %d.\n", ((X)*(X)));
```
假设这样使用宏：
PSQR(8);
输出为：
The square of X is 64.
注意双引号字符中中的X被视为普通文本，而不是一个可被替换的记号。
C允许在字符串中包含宏参数。在类函数宏的替换本中，#号作为一个预处理运算符
，可以把记号转换成字符串。例如，如果x是一个宏形参，那么#x就是转换为字符
串“x”的形参名。这个过程称为字符串化(stringizing)。


#### 预处理器黏合剂: ##运算符
与#运算符类似，##运算符可用于类函数宏的替换部分。而且，##还可用于对象宏的
替换部分。##运算符把两个记号组合成一个记号。
```c
#define XNAME(n) x ## n
```
然后，宏XANME(4)将展开为x4.


#### 变参宏: ...和__VA_ARGS__
一些函数(如printf())接受数量`可变(variadic)量的参数`。stdvar.h头文件提供了工具，让用户
自定义带可变参数的函数。
通过把宏参数列表中最后的参数写成省略号(即，3个点...)来实现这一功能。
这样，预定义宏__VA_ARGS__可用在替换部分中，表明省略号代表什么。
```c
#define PR(...) printf(__VA_ARGS__)
```
假设稍后调用该宏：
```c
PR("Howdy");
PR("Weight=%d, shipping=$%.2f\n", wt, sp);
```
第1次调用，__VA_ARGS__展开为1个参数："Howdy".
第2次调用，__VA_ARGS__展开为3个参数了:"weight=%d shipping=$%.2f\n"、wt、
sp.


#### 宏和函数的选择
使用宏比使用普通函数复杂一些，稍有不慎会产生奇怪的副作用。一些编译器规定宏只能定义成一行。
不过，即使编译器没有这个限制，也应该这样做。

宏和函数的选择实际上是时间和空间的权衡。
宏生成内联代码，即在程序中生成语句。如果调用20次宏，即在程序中插入20行代码。如果调用函数
20次，程序中只有一份函数语句的副本，所以节省了空间。然而另一方面，程序的控制必须跳转至函数
内，随后再返回主调程序，这显然比内联代码花费更多时间。
宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而不是实际的值).

在嵌套循环中使用宏更有助于提高效率。
