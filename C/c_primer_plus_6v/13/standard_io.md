#### 检查命令行参数
exit()函数的取值，C标准规定了一个最小的限制范围。
标准要求0或宏EXIT_SUCCESS用于表明成功结束程序，EXIT_FAILURE用于表明结束程序
失败。这些宏和exit()原型位于stdlib.h头文件中。

根据ANSI c的规定，在最初调用的main()中使用return与调用exit()的效果相同。
因此，在main(),下面的语句：
```c
return 0;
// 等价于
exit(0);
```
但是要注意，我们说的是"最初的调用“，如果main()在一个递归程序中，exit()仍然会
终止程序，但是return只会把控制权交给上一级递归，直至最初的一级。然后return结
束程序。
return和exit()的另一个区别是，即使在其他函数中（除main()以外）调用exit()也能
结束整个程序。


#### fopen()函数
| 模式字符串 | 含义 |
|-|:-:|:-:|-:|
| "r" | 以读模式打开文件 |
| "w" | 以写模式打开文件，把现有文件的长度截为0,如果文件不存在，则创建一个新文件 |
| "a" | 以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件 |
| "r+" | 以更新模式打开文件（即可以读写文件) |
| "w+" | 以更新模式打开文件（即，读和写），如果文件存在，则将其长度截为0;如果文件不存在，则创建一个新文件 |
| "a+" | 以更新模式打开文件（即，读和写），在现有文件的末尾添加内容，如果文件不存在则创建一个新文件;可以读整个文件，但是只能从末尾添加内容 |
| "rb"、"wb"、"ab"、"ab+"、"a+b"、"wb+"、"w+b"、"ab+"、"a+b" | 与上一个模式类似，但是以二进制模式而不是文本模式打开文件 |
| "wx"、"wbx"、"w+x"、"wb+x"或"w+bx" | (c11)类似非x模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败 |


像UNIX和Linux这样只有一种文件类型的系统,带b字母的模式和不带b字母的模式相同。

新的C11新增了带x字母的写模式,与以前的写模式相比具有更多特性。第一,如果以传统的一种
写模式打开一个现有文件,fopen()会把该文件的长度截为 0,这样就丢失了该文件的内容。但是
使用带 x字母的写模式,即使fopen()操作失败,原文件的内容也不会被删除。第二,如果环境允许,
x模式的独占特性使得其他程序或线程无法访问正在被打开的文件。

如果使用任何一种"w"模式(不带x字母)打开一个现有文件,该文件的内容会被删除,以便程序在
一个空白文件中开始操作。然而,如果使用带x字母的任何一种模式,将无法打开一个现有文件。

程序成功打开文件后，fopen()将返回文件指针(file pointer), 其他I/O函数可以使用这个指针
指定该文件。
文件指针的类型是指向FILE的指针，FILE是一个定义在stdio.h中的派生类型。文件指针fp并不指向
实际的文件，它指向一个包含文件信息的数据对象，其中包含操作文件的I/O函数所用的缓冲区信息。
因为标准库中的I/O函数使用缓冲区，所以它们不仅要知道缓冲区被填充的程序以及操作哪一个文件。
标准I/O函数根据这些信息在必要时决定再次填充或清空缓冲区。


#### 标准I/O的机理
通常，使用标准I/O的第1步是调用fopen()打开文件(前面介绍过，C程序会自动打开3种标准文件).
fopen()函数不仅打开一个文件，还创建了一个缓冲区(在读写模式下会创建两个缓冲区)以及一个包含
文件和缓冲区数据的结构。另外，fopen()返回一个指向该结构的指针，以便其他函数知道如何找到该
结构。假设把该指针赋给一个指针变量fp,我们说fopen()函数"打开一个流".如果以文本模式打开该文
件，就获得一个文本流;如果以二进制模式打开该文件，就获得一个二进制流。

这个结构通常包含一个指定流中当前位置的文件位置指示器。除此之外，它还包含错误和文件结尾的指
示器、一个指向缓冲区开始处的指针、一个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数).

通常，使用标准I/O的第2步是调用一个定义在stdio.h中的输入函数，如fscanf()、getc()或fgets()。
一调用这些函数，文件中的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而异，一般是512字节或
是它的倍数，如4096或16384(随着计算机硬盘容量越来越大，缓冲区的大小也越来越大)。最初调用函
数，除了填充缓冲区外，还要设置fp所指向的结构中的值。尤其要设置流中的当前位置和拷贝时缓冲区
的字节数。通常，当前位置从字节0开始。

在初始化结构和缓冲区后，输入函数按要求从缓冲区中读取数据。在它读取数据时，文件位置指示器被
设置为指向刚读取字符的下一个字符。由于stdio.h系列的所有输入函数都使用相同的缓冲区，所以调用
任何一个函数都将从上一次函数停止调用的位置开始。

当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区
中。以这种方式，输入函数可以读取文件中的所有内容，直到文件结尾。函数在读取缓冲区的最后一个字
符后，把结尾指示器设置为真，于是，下一次被调用的输入函数将返回EOF.

输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。


