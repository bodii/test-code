#### 缓冲区

如果在老式系统运行中：
输入HHEELLOO...
以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符是属于`无缓冲`
(或直接)输入，即正在等待的程序可立即使用输入的字符。对于该例，大部分系统在用
户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于`缓冲输入`。用户输
入的字符被收集并储存在一个被称为`缓冲区(buffer)`的临时存储区，按下Enter键后，
程序才可使用用户输入的字符。


#### 为什么要有缓冲区
首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打
错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。
虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望
按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。


#### 缓冲分为两类：
* 完全缓冲I/O
* 行缓冲I/O

> 完全缓冲输入指的是当缓冲区被填満时才刷新缓冲区(内容被发送至目的地),通常出现在
文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节。
> 行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下
Enter键后才刷新缓冲区。


#### UNIX系统下，C的缓冲操作
在UNIX中， 可以使用ioctl()函数(该函数属于UNIX库，但是不属于C标准)指定待输入的类型，
然后用getchar()执行相应的操作。

在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些
函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无
缓冲输入取决于计算机系统。


#### 文件、流和键盘输入
> 文件 是存储器中储存信息的区域。通常，文件都保存在某种永久存储器中(如，硬盘、U盘
或DVD等).
当编译储存在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容。当编译
器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打开、读取和关闭文件，还
要把数据写入文件。
C是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，
C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底
层I/O(low-level I/O).由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库
，ANSI C也不打算这样做。然而从较高层面上，C还可以通过`标准I/O包(standard I/O package)`
来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C
实现负责处理不同系统的差异，以便用户使用统一的界面。
C程序处理的是而不是直接处理文件。

> 流(stream) 是一个实际输入或输出映射的理想化数据流。
这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把
流与文件相关联，而且读写都通过流来完成。
C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打
开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、printf()
和scanf()函数都有是标准I/O包的成员，处理这两个流。


#### 文件结尾
计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾
放一个特殊的字符标记文件结尾。
无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾
时返回一个特殊的值，即`EOF(end of file缩写)`.scanf()函数检测到文件结尾时也返回EOF.通常，
> EOF定义在stdio.h文件中：
```c
define EOF (-1)
```
为什么是-1?因为getchar()函数的返回值通常都介于0~127,这些值对应标准字符集。但是，如果系统
能识别扩展字符集，该函数的返回值可能在0~255之间。无论哪种情况，-1都不对应任何字符，所以，
该值可用于标记文件结尾。

> 如何在程序中使用EOF? 把getchar()的返回值和EOF作比较。如果两值不同，就说明没有到达文件结
尾。也就是说，可以使用下面这样的表达式：
```c
while ((ch = getchar()) != EOF)
```
变量ch的类型从char变为int，因为char类型的变量只能表示0~255的无符号整数，但是EOF的值是-1，
getchar()函数实际返回值的类型是int,所以它可以读取EOF字符。由于getchar()函数的返回类型是
int,如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据.


#### 重定向和文件
重定向是一个命令行概念，因为要在命令行输入特殊的符号发出指令。


#### 混合数值和字符输入
getchar() 读取每个字符，包括空格、制表符和换行符;
scanf()  在读取数字时则会跳过空格、制表符和换行符。


#### 输入流和数字
在输入：
is 28 12.4
在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对C程序而言，这是`一个字节
流`.
第1个字节是字母i的字符编码，第2个字节是s的字符编码，第3个字节是空格字符的字符编码...
