#### 数组
`数组由数据类型相同的一系列元素组成.`
需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些
元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用
的类型，数组元素都可以用。

方括号([])中的数字表明数组中的元素个数。

要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素。
数组元素从0开始。

只储存单个值的变量有时也称为`标量变量(scalar variable)`:
```c
int fix = 1;
float flax = PI * 2;
```

在代码中的PI已定义为宏。C使用新的语法来初始化数组:
```c
int main(void)
{
	int powers[8] = { 1, 2, 3, 4, 5, 6, 7, 7 }; /* 从ANSI C开始支持这种初始化 */
}
```


#### 数组初始化
有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要
创建只读数组, 应该用const声明和初始化数组。


> 当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0.也就是说，
如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都有是垃圾值：
但是，如果部分初始化数组，剩余的元素就会被初始化为0.

> 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。

> 计算数组的长度= sizeof(数组) / sizeof(数组[0]);
sizeof运算符给出它的运算对象的大小(以字节为单位)。


#### 指定初始化器(C99)
C99增加了一个新特性:`指定初始化器(designated initializer)`。利用该特性可以初始化指定
的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后
一个元素之前的所有元素，才能初始化定：
```c
int arr[6] = { 0, 0, 0, 0, 0, 212 }; // 传统的语法
```
而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素:
```c
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212
```
对于一般的初始化，在初始化一个元素后， 未初始化的元素都会被设置为0。

```c
int days[10] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
// days的值为 31, 29, 0, 0, 31, 30, 31, 0, 0, 0
```

如果未指定元素大小会怎样：
```c
int stuff[] = { 1, [6] = 23 };
int staff[] = { 1, [6] = 4, 9, 10 };
```
> 编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为
0~6: 而staff数组的元素比stuff数组多个两个,即有9个元素.


#### 给数组元素赋值
> C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式
赋值。

```c
/* 一些无效的数组赋值 */
#define SIZE 5

int main(void)
{
	int oxen[SIZE] = { 5, 3, 2, 8 }; /* 初始化没有问题 */
	int yaks[SIZE];  

	yaks = oxen;  /* 不允许 */
	yaks[SIZE] = oxen[SIZE];  /* 数组下标越界 */
	yaks[SIZE] = { 5, 3, 2, 8 }; /* 不起作用 */
}
```
oxen数组的最后一个元素是oxen[SIZE-1], 所以oxen[SIZE]和yaks[SIZE]都超出了两个数组的
末尾。


#### 数组边界
在使用数组时，要防止数组下标超出边界，也就是说，必须确保下标是有效的值。例如:
int doofi[20];
那么在使用该数组时，要确保程序中使用的数组下标在0~19的范围内，因为编译器不会检查出这
种错误（但是，一些编译器发出警告，然后继续编译程序).
