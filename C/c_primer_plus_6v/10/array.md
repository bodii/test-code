#### 数组
`数组由数据类型相同的一系列元素组成.`
需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些
元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用
的类型，数组元素都可以用。

方括号([])中的数字表明数组中的元素个数。

要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素。
数组元素从0开始。

只储存单个值的变量有时也称为`标量变量(scalar variable)`:
```c
int fix = 1;
float flax = PI * 2;
```

在代码中的PI已定义为宏。C使用新的语法来初始化数组:
```c
int main(void)
{
	int powers[8] = { 1, 2, 3, 4, 5, 6, 7, 7 }; /* 从ANSI C开始支持这种初始化 */
}
```


#### 数组初始化
有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要
创建只读数组, 应该用const声明和初始化数组。


> 当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0.也就是说，
如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都有是垃圾值：
但是，如果部分初始化数组，剩余的元素就会被初始化为0.

> 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。

> 计算数组的长度= sizeof(数组) / sizeof(数组[0]);
sizeof运算符给出它的运算对象的大小(以字节为单位)。


#### 指定初始化器(C99)
C99增加了一个新特性:`指定初始化器(designated initializer)`。利用该特性可以初始化指定
的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后
一个元素之前的所有元素，才能初始化定：
```c
int arr[6] = { 0, 0, 0, 0, 0, 212 }; // 传统的语法
```
而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素:
```c
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212
```
对于一般的初始化，在初始化一个元素后， 未初始化的元素都会被设置为0。

```c
int days[10] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
// days的值为 31, 29, 0, 0, 31, 30, 31, 0, 0, 0
```

如果未指定元素大小会怎样：
```c
int stuff[] = { 1, [6] = 23 };
int staff[] = { 1, [6] = 4, 9, 10 };
```
> 编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为
0~6: 而staff数组的元素比stuff数组多个两个,即有9个元素.


#### 给数组元素赋值
> C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式
赋值。

```c
/* 一些无效的数组赋值 */
#define SIZE 5

int main(void)
{
	int oxen[SIZE] = { 5, 3, 2, 8 }; /* 初始化没有问题 */
	int yaks[SIZE];  

	yaks = oxen;  /* 不允许 */
	yaks[SIZE] = oxen[SIZE];  /* 数组下标越界 */
	yaks[SIZE] = { 5, 3, 2, 8 }; /* 不起作用 */
}
```
oxen数组的最后一个元素是oxen[SIZE-1], 所以oxen[SIZE]和yaks[SIZE]都超出了两个数组的
末尾。


#### 数组边界
在使用数组时，要防止数组下标超出边界，也就是说，必须确保下标是有效的值。例如:
int doofi[20];
那么在使用该数组时，要确保程序中使用的数组下标在0~19的范围内，因为编译器不会检查出这
种错误（但是，一些编译器发出警告，然后继续编译程序).

编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着
程序看上去可以运行，但是运行结果很奇怪，或异常中止。
使用越界的数组下标会导致程序改变其他变量的值。

最好在声明数组时使用符号常量来表示数组的大小


#### 指定数组的大小
```c
#define SIZE 4
int main(void)
{
	int arr[SIZE]; // 整数符号常量
	double lots[144]; // 整数字面常量
	...
}
```

#### 多维数组
```c
float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素
```


#### 初始化二维数组
初始化二维数组是建立在初始化一维数组的基础上。

二维数组的相关内容都适用于三维数组或更多维的数组。


#### 指针和数组
指针提供一种以符号形式使用地址的方法。
因为计算机的硬件指令非常依赖地址，指针在某种程序上把程序员想要传达的指令以更接近机
器的方式表达。
因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。

> 在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着加1的地址是下一个元素的
地址，而不是下一个字节的地址。这是为什么必须声明指针所指向的对象类型的原因之一。
只知道地址不够，因为计算机要知道储存对象需要多少字节。


* 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机(包
括PC和Macintosh)都有是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大
对象的地址(如double类型的变量)通常是该对象第一个字节的地址。

* 在指针前面使用*运算符可以得到该指针所指向对象的值。

* 指针加1, 指针的值递增它所指向类型的大小(以字节为单位).

C语言标准在描述数组表示法时借助了指针，也就是说，定义ar[n]的意思是*(ar+n).可以认为*(
ar+n)的意思是`"到内存的ar位置，然后移动n个单元，检索储存在那里的值"`。
不要混淆*(dates+2)和*dates+2。间接运算符(*)的优先级高于+,所以*dates+2相当于(*dates)+2
*(dates + 2)  // dates,第3个元素的值
*dates+2 // dates，第1个元素的值加2

`数组名是该数组首元素的地址。`
指针表示法和数组表示法是两种等效的方法


#### 函数、数组手指针
关于函数的形参，要注意,只有在函数原型或函数定义头中，才可以用int ar[]代替int * ar:
int sum(int ar[], int n);
int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只能用于声明形式参
数。第2种形式(int ar[])提醒读者指针ar指向的不仅仅一个int类型值，还是一个int类型数组的元
素。

因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针，
只有在这种情况下，C才会把int ar[]和int * ar解释成一样。也就是说，ar是指向int的指针，由于
函数原型可以省略参数名，所以下面4种原型都是等价的：
```c
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```
但是，在函数定义中不能省略参数名。

