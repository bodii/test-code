#### 数组
`数组由数据类型相同的一系列元素组成.`
需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些
元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用
的类型，数组元素都可以用。

方括号([])中的数字表明数组中的元素个数。

要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素。
数组元素从0开始。

只储存单个值的变量有时也称为`标量变量(scalar variable)`:
```c
int fix = 1;
float flax = PI * 2;
```

在代码中的PI已定义为宏。C使用新的语法来初始化数组:
```c
int main(void)
{
	int powers[8] = { 1, 2, 3, 4, 5, 6, 7, 7 }; /* 从ANSI C开始支持这种初始化 */
}
```


#### 数组初始化
有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要
创建只读数组, 应该用const声明和初始化数组。


> 当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0.也就是说，
如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都有是垃圾值：
但是，如果部分初始化数组，剩余的元素就会被初始化为0.

> 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。

> 计算数组的长度= sizeof(数组) / sizeof(数组[0]);
sizeof运算符给出它的运算对象的大小(以字节为单位)。


#### 指定初始化器(C99)
C99增加了一个新特性:`指定初始化器(designated initializer)`。利用该特性可以初始化指定
的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后
一个元素之前的所有元素，才能初始化定：
```c
int arr[6] = { 0, 0, 0, 0, 0, 212 }; // 传统的语法
```
而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素:
```c
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212
```
对于一般的初始化，在初始化一个元素后， 未初始化的元素都会被设置为0。

```c
int days[10] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
// days的值为 31, 29, 0, 0, 31, 30, 31, 0, 0, 0
```

如果未指定元素大小会怎样：
```c
int stuff[] = { 1, [6] = 23 };
int staff[] = { 1, [6] = 4, 9, 10 };
```
> 编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为
0~6: 而staff数组的元素比stuff数组多个两个,即有9个元素.


#### 给数组元素赋值
> C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式
赋值。

```c
/* 一些无效的数组赋值 */
#define SIZE 5

int main(void)
{
	int oxen[SIZE] = { 5, 3, 2, 8 }; /* 初始化没有问题 */
	int yaks[SIZE];  

	yaks = oxen;  /* 不允许 */
	yaks[SIZE] = oxen[SIZE];  /* 数组下标越界 */
	yaks[SIZE] = { 5, 3, 2, 8 }; /* 不起作用 */
}
```
oxen数组的最后一个元素是oxen[SIZE-1], 所以oxen[SIZE]和yaks[SIZE]都超出了两个数组的
末尾。


#### 数组边界
在使用数组时，要防止数组下标超出边界，也就是说，必须确保下标是有效的值。例如:
int doofi[20];
那么在使用该数组时，要确保程序中使用的数组下标在0~19的范围内，因为编译器不会检查出这
种错误（但是，一些编译器发出警告，然后继续编译程序).

编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着
程序看上去可以运行，但是运行结果很奇怪，或异常中止。
使用越界的数组下标会导致程序改变其他变量的值。

最好在声明数组时使用符号常量来表示数组的大小


#### 指定数组的大小
```c
#define SIZE 4
int main(void)
{
	int arr[SIZE]; // 整数符号常量
	double lots[144]; // 整数字面常量
	...
}
```


#### 函数的数组形参
只有在函数原型或函数定义头中，才可以用int ar[]代替int * ar:
```c
int sum(int ar[], int n);
```
int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只能用于声明形参。
第2种形式(int ar[])提醒读者指针ar指向的不仅仅一个int类型值，还是一个int型数组的元素。


#### 多维数组
```c
float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素
```


#### 初始化二维数组
初始化二维数组是建立在初始化一维数组的基础上。

二维数组的相关内容都适用于三维数组或更多维的数组。


#### 指针和数组
指针提供一种以符号形式使用地址的方法。
因为计算机的硬件指令非常依赖地址，指针在某种程序上把程序员想要传达的指令以更接近机
器的方式表达。
因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。

> 在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着加1的地址是下一个元素的
地址，而不是下一个字节的地址。这是为什么必须声明指针所指向的对象类型的原因之一。
只知道地址不够，因为计算机要知道储存对象需要多少字节。


* 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机(包
括PC和Macintosh)都有是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大
对象的地址(如double类型的变量)通常是该对象第一个字节的地址。

* 在指针前面使用*运算符可以得到该指针所指向对象的值。

* 指针加1, 指针的值递增它所指向类型的大小(以字节为单位).

C语言标准在描述数组表示法时借助了指针，也就是说，定义ar[n]的意思是*(ar+n).可以认为*(
ar+n)的意思是`"到内存的ar位置，然后移动n个单元，检索储存在那里的值"`。
不要混淆*(dates+2)和*dates+2。间接运算符(*)的优先级高于+,所以*dates+2相当于(*dates)+2
*(dates + 2)  // dates,第3个元素的值
*dates+2 // dates，第1个元素的值加2

`数组名是该数组首元素的地址。`
指针表示法和数组表示法是两种等效的方法


#### 函数、数组手指针
关于函数的形参，要注意,只有在函数原型或函数定义头中，才可以用int ar[]代替int * ar:
int sum(int ar[], int n);
int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只能用于声明形式参
数。第2种形式(int ar[])提醒读者指针ar指向的不仅仅一个int类型值，还是一个int类型数组的元
素。

因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针，
只有在这种情况下，C才会把int ar[]和int * ar解释成一样。也就是说，ar是指向int的指针，由于
函数原型可以省略参数名，所以下面4种原型都是等价的：
```c
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```
但是，在函数定义中不能省略参数名。


#### 优先级
```c
total += *start++;
```
一元运算符*和++的优先级相同，但结合律是从右往左，所以start++先求值，然后才是*start.
也就是说，指针start先递增后指向。
如果使用*++start,顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使用(*start)++,
则先使用start指向的值，再递增该值，而不是递增指针。这样，指针将一直接向同一个位置，但是
该位置上的值发生了变化。


#### 指针表示法和数组表示法
指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率
更高的代码。


#### 指针操作
* 赋值： 可以把地址赋给指针。例如，用数组名、带地址运算符(&)的变量名、另一个指针进行赋值。
注意，地址应该和指针类型兼容。

* 解引用： *运算符给出指针指向地址上储存的值。

* 取址： 和所有变量一样，指针变量也有自己的地址和值。对指针而言，&运算符给出指针本身的地址。

* 指针与整数相加：可以使用+ 运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都
会和指针所指向类型的大小(以字节为单位)相乘，然后把结果与初始地址相加。

* 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。

* 指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是
第二个运算对象。该整数将乘以指针指向类型的大小(以字节为单位),然后用初始地址减去乘积。

* 递减指针：当然，除了递增指针还可以递减指针。

* 指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算
求出两元素之间的距离。差值的单位与数组类型的单位相同。

* 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。

在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C只能保证指向数组任意
元素的指针和指向数组后面第1个位置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是
未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置有效的，也
能解引用这样的越界指针。


#### 指针的作用
1. 在函数间传递信息;
2. 在处理数组的函数中。


#### 保护数组中的数据
通常都是直接传递数值，只有程序需要在函数中改变数值时，才会传递指针。
对于数组，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间储存
原数组的副本，然后把原数组所有的数据拷贝至新的数组中。


#### const的其他内容
虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加灵活。可以创建const数组、const
指针和指向const的指针。
C标准规定，使用非const标识符修改const数据，导致的结果是未定义的。
const还可以声明并初始化一个不能指向别处的指针：
```c
double rates[5] = { 8.9, 1.45, 2.38, 6.77, 5.25 };
double * const pc = rates; // pc指向数组的开始
pc = &rates[2]; // 不允许，因为该指针不能指向别外
*pc = 92.99; // 没问题——更改rates[0]的值
```
可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。

在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值：
```c
double rates[5] = { 8.9, 1.45, 2.38, 6.77, 5.25 };
const double * const pc = rates;
pc = &rates[2]; // 不允许
*pc = 92.99;    // 不允许
```


#### 指针和多维数
解引用两次（二维）才能获得原始值(**zippo与*&zippo[0][0]等价),地址的地址或指针的指针就是双
重间接(double indirection).


#### 指向多维数组的指针
pz(二维数组zippo)必须指向一个内含两个int类型的数组，而不是指向一个int类型值:
```c
int (* pz)[2]; // pz指向一个内含两个int类型的数组
```c
使用()是由于[]优先级高于*.

可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：
```c
zippo[m][n] == *(*(zipp + m) +n);
pz[m][n] == *( *(pz +m) +n);
```


#### 指针的兼容性
指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把int类型的值赋给
double类型的变量，但是两个类型的指针不能这样做。
```c
int n = 5;
double x;
int * p1 = &n;
double * pd = &x;
x = n;  // 隐式类型转换
pd = p1;  // 编译时错误

//更复杂的类型也是如此：
int * pt;
int (*pa)[3]; // 声明一个指向二维数组的指针，第二维有每个中有3个int类型的值。
int ar1[2][3];
int ar2[3][2];
int **p2; // 一个指向指针的指针

// 如下
pt = &ar1[0][0]; // 都是指向int的指针
pt = ar1[0];     // 都是指向int的指针
pt = ar1;        // 无效
pa = ar1;        // 都是指向内含3个int类型元素数组的指针
pa = ar2;        // 无效
p2 = &pt;        // both pointer-to-int *
*p2 = ar2[0]     // 都是指向int的指针
p2 = ar2;        // 无效

// 多重解引用：
int x = 20;
const int y = 23;
int * p1 = &x;
const int * p2 = &y;
const int ** pp2;
p1 = p2;   // 不安全 —— 把const指针赋给非const指针
p2 = p1;   // 有效 —— 把非const指针赋给const指针
pp2 = &p1;   // 不安全 —— 嵌套指针类型赋值
```
把const指针赋给非const指针不安全，因为这样可以使用新的指针改变const指针指向的
数据。编译器不编译代码时，可能会给出警告，执行这样的代码是未定义。但是把非const
指针赋给const指针没问题，前指是只时行一级解引用：
```c
p2 = p1; // 有效 —— 把非const指针赋给const指针

// 但是进行两级解引用时，这样的赋值也不安全
const int **pp2;
int *p1;
const int n = 13;
pp2 = &p1; // 允许，介是这导致const限定符失败
*pp2 = &n; // 有效，两者都声明为const,但是这将导致p1指向n
*p1 = 10; // 有效，但是这样改变n的值
```


#### 函数和多维数组
如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参.
数组junk是一个内含3个数组元素的数组，每个元素是内含4个int类型的数组。
可以这样声明函数的参数：
```c
void somefunction( int (* pt)[4] );
// 或
void somefunction( int pt[][4] );
```
注意，第1个方括号是空的，空的方括号表明pt是一个指针。
下面的声明不正确：
```c
int sum2(int ar[][], int rows); // 错误的声明
```
编译器会把数组表示法转换成指针表示法。例如，编译器会把ar[1]轮换成ar+1.编译器对
ar+1求值，要知道ar所指向的对象大小
```c
int sum2(int ar[][4], int rows);  // 有效声明
```
表示ar指向一个内含4个int类型值的数组（在我们的系统中，ar指向的对象占16字节),所以
ar+1的意思是"该地址加上16字节",如果第2对方括号是空的，编译器就不知道怎样处理。
```c
int sum2(int ar[3][4], int rows); // 有效声明，但是3将被忽略
```
与使用typedef相比，这种形式方便得多：
```c
typedef int arr4[4];   // arr4是一个内含4个int的数组
typedef arr4 arr3x4[3];  // arr3x4 是一个内含3个arr4的数组
int sum2(arr3x4 ar, int rows);   // 与下面的声明相同
int sum2(int ar[3][4], int rows); // 与下面的声明相同
int sum2(int ar[][4], int rows);   // 标准形式
```
一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值:
```c
int sum4d(int ar[][12][20][30], int rows);
```
因为第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数组对象的类型
```c
int sum4d(int (*ar)[12][20][30], int rows);  // ar是一个指针
```
这里，ar指向一个12x20x30的int数组。


#### 变长数组(VLA)
假设声明了下列数组：
```c
int array1[5][4];
int array2[100][4];
int array3[2][4];
```
可以用sum2d()函数分别计算这些数组的元素之和:
```c
tot = sum2d(array1, 5);    // 5x4数组的元素之和
tot = sum2d(array2, 100);  // 100x4数组的元素之和
tot = sum2d(array3, 2);    // 2x4数组的元素之和
```
sum2d()函数之所以能处理这些数组，是因为这些数组的列数固定为4，而行数被传递给形参rows,
rows是一个变量。

C99 新增了`变长数组(variable-length array, VLA)`, 允许使用变量表示数组的维度。
```c
int auarters = 4;
int regions = 5;
double sales[regions][quarters];    // 一个变长数组(VLA)
```
注意 变长数组不能改变大小
变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。
这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。
```c
int sum2d(int rows, int cols, int ar[rows][cols]);  // ar是一个变长数组(VLA)
```
前两个形参(rows和cols)用作第3个形参二维数组ar的两个维度。因为ar的声明要使用rows和cols,所以
在形参列表中必须在声明ar之前先声明这两个形参。
C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度:
```c
int sum2d(int , int , int ar[*][*]);  // ar 是一个变长数组(VLA), 省略了维度形参名
```
在函数定义的形参列表中声明的变长数组并未实际创建数组。
和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组
中处理数组，因此可以修改传入的数组.

```c
int thing[10][6];
twoset(10, 6, thing);

void twoset(int n, int m, int ar[n][m])   // ar是一个指向数组(内含m个int类型的值)的指针
{
	int temp[n][m]; // temp是一个nxm的int数组
	temp[0][0] = 2;   // 设置temp的一个元素为2
	ar[0][0] = 2;     // 设置thing[0][0]为2
}
```
如上，调用twoset()时，ar成为指向thing[0]的指针，temp被创建为10x6的数组。因为ar和thing都
是指向thing[0]的指针，ar[0][0]和thing[0][0]访问的数据位置相同。

C99/C11标准允许在声明变长数组时使用const变量。所以该数组的定义必须是声明在块中的自动存储
类别数组。
变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通C数组都是静态内存
分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译在编译时就知道了。


#### 复合字面量
C99新增了`复合字面量(compound literal)`.字面量是除符号常量外的常量。例如以，5是int类型字面
量。
对于数组，复合字面量类似数组初始化列表中，前面是用括号括起来的类型名。如：
```c
int diva[2] = { 10, 20 };
```
复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值:
```c
(int [2]) { 10, 20 };   // 复合字面量
```
去掉声明中的数组名,所以不能先创建然后再使用它，必须在创建同时使用它。使用指针记录地址就是
一种用法：
```c
int * pt1;
pt1 = (int [2]) { 10, 20 };
```

还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：
```c
int sum(const int ar[], int n);

int total3;
total3 = sum((int []){4, 4, 4, 5, 5, 5}, 6);
```

可以把这种用法用于二维数组或多维数组。
```c
int (*pt2) [4]; // 声明一个指向二维数组的指针，该数组内含2个数组元素，
				// 每个元素是内含4个int类型值的数组
pt2 = (int [2][4]){ { 1, 2, 3, -9 }, { 4, 5, 6, -8 } };
```


#### 关键概念
数组用于储存相同类型的数据。C把数组看作是派生类型，因为数组是建立在其他类型的基础上。
也就是说，无法简单地声明一个数组。在声明数组时必须说明其元素的类型，如int类型的数组。
通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题，有助于实现程序的模块化。
在把数组名作为实际参数时，传递给函数的不是整个数组，而是数组的地址(因为，函数对应的形
式参数是指针).为了处理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。
数组和指针的关系密切，同一操作可以用数组表示法或指针表示法。它们之间的关系允许你在处理
数组的函数中使用数组表示法，即使函数的形式参数是一个指针，而不是数组。
对于传统的C数组，必须用常量表达式指明数组的大小，所以数组大小在编译时就已确定。C99/C11
新增了变长数组，可以用变量表示数组大小，这意味着变长数组的大小延迟到程序运行时才确定。


