#### 数组
`数组由数据类型相同的一系列元素组成.`
需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些
元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用
的类型，数组元素都可以用。

方括号([])中的数字表明数组中的元素个数。

要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素。
数组元素从0开始。

只储存单个值的变量有时也称为`标量变量(scalar variable)`:
```c
int fix = 1;
float flax = PI * 2;
```

在代码中的PI已定义为宏。C使用新的语法来初始化数组:
```c
int main(void)
{
	int powers[8] = { 1, 2, 3, 4, 5, 6, 7, 7 }; /* 从ANSI C开始支持这种初始化 */
}
```


#### 数组初始化
有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要
创建只读数组, 应该用const声明和初始化数组。


> 当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0.也就是说，
如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都有是垃圾值：
但是，如果部分初始化数组，剩余的元素就会被初始化为0.

> 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。

> 计算数组的长度= sizeof(数组) / sizeof(数组[0]);
sizeof运算符给出它的运算对象的大小(以字节为单位)。


#### 指定初始化器(C99)
C99增加了一个新特性:`指定初始化器(designated initializer)`。利用该特性可以初始化指定
的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后
一个元素之前的所有元素，才能初始化定：
```c
int arr[6] = { 0, 0, 0, 0, 0, 212 }; // 传统的语法
```
而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素:
```c
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212
```
对于一般的初始化，在初始化一个元素后， 未初始化的元素都会被设置为0。

```c
int days[10] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
// days的值为 31, 29, 0, 0, 31, 30, 31, 0, 0, 0
```

如果未指定元素大小会怎样：
```c
int stuff[] = { 1, [6] = 23 };
int staff[] = { 1, [6] = 4, 9, 10 };
```
> 编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为
0~6: 而staff数组的元素比stuff数组多个两个,即有9个元素.


#### 给数组元素赋值
> C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式
赋值。

```c
/* 一些无效的数组赋值 */
#define SIZE 5

int main(void)
{
	int oxen[SIZE] = { 5, 3, 2, 8 }; /* 初始化没有问题 */
	int yaks[SIZE];  

	yaks = oxen;  /* 不允许 */
	yaks[SIZE] = oxen[SIZE];  /* 数组下标越界 */
	yaks[SIZE] = { 5, 3, 2, 8 }; /* 不起作用 */
}
```
oxen数组的最后一个元素是oxen[SIZE-1], 所以oxen[SIZE]和yaks[SIZE]都超出了两个数组的
末尾。


#### 数组边界
在使用数组时，要防止数组下标超出边界，也就是说，必须确保下标是有效的值。例如:
int doofi[20];
那么在使用该数组时，要确保程序中使用的数组下标在0~19的范围内，因为编译器不会检查出这
种错误（但是，一些编译器发出警告，然后继续编译程序).

编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着
程序看上去可以运行，但是运行结果很奇怪，或异常中止。
使用越界的数组下标会导致程序改变其他变量的值。

最好在声明数组时使用符号常量来表示数组的大小


#### 指定数组的大小
```c
#define SIZE 4
int main(void)
{
	int arr[SIZE]; // 整数符号常量
	double lots[144]; // 整数字面常量
	...
}
```


#### 函数的数组形参
只有在函数原型或函数定义头中，才可以用int ar[]代替int * ar:
```c
int sum(int ar[], int n);
```
int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只能用于声明形参。
第2种形式(int ar[])提醒读者指针ar指向的不仅仅一个int类型值，还是一个int型数组的元素。


#### 多维数组
```c
float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素
```


#### 初始化二维数组
初始化二维数组是建立在初始化一维数组的基础上。

二维数组的相关内容都适用于三维数组或更多维的数组。


#### 指针和数组
指针提供一种以符号形式使用地址的方法。
因为计算机的硬件指令非常依赖地址，指针在某种程序上把程序员想要传达的指令以更接近机
器的方式表达。
因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。

> 在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着加1的地址是下一个元素的
地址，而不是下一个字节的地址。这是为什么必须声明指针所指向的对象类型的原因之一。
只知道地址不够，因为计算机要知道储存对象需要多少字节。


* 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机(包
括PC和Macintosh)都有是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大
对象的地址(如double类型的变量)通常是该对象第一个字节的地址。

* 在指针前面使用*运算符可以得到该指针所指向对象的值。

* 指针加1, 指针的值递增它所指向类型的大小(以字节为单位).

C语言标准在描述数组表示法时借助了指针，也就是说，定义ar[n]的意思是*(ar+n).可以认为*(
ar+n)的意思是`"到内存的ar位置，然后移动n个单元，检索储存在那里的值"`。
不要混淆*(dates+2)和*dates+2。间接运算符(*)的优先级高于+,所以*dates+2相当于(*dates)+2
*(dates + 2)  // dates,第3个元素的值
*dates+2 // dates，第1个元素的值加2

`数组名是该数组首元素的地址。`
指针表示法和数组表示法是两种等效的方法


#### 函数、数组手指针
关于函数的形参，要注意,只有在函数原型或函数定义头中，才可以用int ar[]代替int * ar:
int sum(int ar[], int n);
int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只能用于声明形式参
数。第2种形式(int ar[])提醒读者指针ar指向的不仅仅一个int类型值，还是一个int类型数组的元
素。

因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针，
只有在这种情况下，C才会把int ar[]和int * ar解释成一样。也就是说，ar是指向int的指针，由于
函数原型可以省略参数名，所以下面4种原型都是等价的：
```c
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```
但是，在函数定义中不能省略参数名。


#### 优先级
```c
total += *start++;
```
一元运算符*和++的优先级相同，但结合律是从右往左，所以start++先求值，然后才是*start.
也就是说，指针start先递增后指向。
如果使用*++start,顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使用(*start)++,
则先使用start指向的值，再递增该值，而不是递增指针。这样，指针将一直接向同一个位置，但是
该位置上的值发生了变化。


#### 指针表示法和数组表示法
指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率
更高的代码。


#### 指针操作
* 赋值： 可以把地址赋给指针。例如，用数组名、带地址运算符(&)的变量名、另一个指针进行赋值。
注意，地址应该和指针类型兼容。

* 解引用： *运算符给出指针指向地址上储存的值。

* 取址： 和所有变量一样，指针变量也有自己的地址和值。对指针而言，&运算符给出指针本身的地址。

* 指针与整数相加：可以使用+ 运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都
会和指针所指向类型的大小(以字节为单位)相乘，然后把结果与初始地址相加。

* 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。

* 指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是
第二个运算对象。该整数将乘以指针指向类型的大小(以字节为单位),然后用初始地址减去乘积。

* 递减指针：当然，除了递增指针还可以递减指针。

* 指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算
求出两元素之间的距离。差值的单位与数组类型的单位相同。

* 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。

在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C只能保证指向数组任意
元素的指针和指向数组后面第1个位置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是
未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置有效的，也
能解引用这样的越界指针。


#### 指针的作用
1. 在函数间传递信息;
2. 在处理数组的函数中。


#### 保护数组中的数据
通常都是直接传递数值，只有程序需要在函数中改变数值时，才会传递指针。
对于数组，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间储存
原数组的副本，然后把原数组所有的数据拷贝至新的数组中。


#### const的其他内容
虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加灵活。可以创建const数组、const
指针和指向const的指针。
C标准规定，使用非const标识符修改const数据，导致的结果是未定义的。
const还可以声明并初始化一个不能指向别处的指针：
```c
double rates[5] = { 8.9, 1.45, 2.38, 6.77, 5.25 };
double * const pc = rates; // pc指向数组的开始
pc = &rates[2]; // 不允许，因为该指针不能指向别外
*pc = 92.99; // 没问题——更改rates[0]的值
```
可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。

在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值：
```c
double rates[5] = { 8.9, 1.45, 2.38, 6.77, 5.25 };
const double * const pc = rates;
pc = &rates[2]; // 不允许
*pc = 92.99;    // 不允许
```


#### 指针和多维数
解引用两次（二维）才能获得原始值(**zippo与*&zippo[0][0]等价),地址的地址或指针的指针就是双
重间接(double indirection).


#### 指向多维数组的指针
pz(二维数组zippo)必须指向一个内含两个int类型的数组，而不是指向一个int类型值:
```c
int (* pz)[2]; // pz指向一个内含两个int类型的数组
```c
使用()是由于[]优先级高于*.

可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：
```c
zippo[m][n] == *(*(zipp + m) +n);
pz[m][n] == *( *(pz +m) +n);
```


#### 指针的兼容性
指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把int类型的值赋给
double类型的变量，但是两个类型的指针不能这样做。
```c
int n = 5;
double x;
int * p1 = &n;
double * pd = &x;
x = n;  // 隐式类型转换
pd = p1;  // 编译时错误

//更复杂的类型也是如此：
int * pt;
int (*pa)[3]; // 声明一个指向二维数组的指针，第二维有每个中有3个int类型的值。
int ar1[2][3];
int ar2[3][2];
int **p2; // 一个指向指针的指针

// 如下
pt = &ar1[0][0]; // 都是指向int的指针
pt = ar1[0];     // 都是指向int的指针
pt = ar1;        // 无效
pa = ar1;        // 都是指向内含3个int类型元素数组的指针
pa = ar2;        // 无效
p2 = &pt;        // both pointer-to-int *
*p2 = ar2[0]     // 都是指向int的指针
p2 = ar2;        // 无效

// 多重解引用：
int x = 20;
const int y = 23;
int * p1 = &x;
const int * p2 = &y;
const int ** pp2;
p1 = p2;   // 不安全 —— 把const指针赋给非const指针
p2 = p1;   // 有效 —— 把非const指针赋给const指针
pp2 = &p1;   // 不安全 —— 嵌套指针类型赋值
```
把const指针赋给非const指针不安全，因为这样可以使用新的指针改变const指针指向的
数据。编译器不编译代码时，可能会给出警告，执行这样的代码是未定义。但是把非const
指针赋给const指针没问题，前指是只时行一级解引用：
```c
p2 = p1; // 有效 —— 把非const指针赋给const指针

// 但是进行两级解引用时，这样的赋值也不安全
const int **pp2;
int *p1;
const int n = 13;
pp2 = &p1; // 允许，介是这导致const限定符失败
*pp2 = &n; // 有效，两者都声明为const,但是这将导致p1指向n
*p1 = 10; // 有效，但是这样改变n的值
```


#### 函数和多维数组
如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参.
数组junk是一个内含3个数组元素的数组，每个元素是内含4个int类型的数组。
可以这样声明函数的参数：
```c
void somefunction( int (* pt)[4] );
// 或
void somefunction( int pt[][4] );
```
注意，第1个方括号是空的，空的方括号表明pt是一个指针。

