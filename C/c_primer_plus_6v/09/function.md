#### 什么是函数
> `函数(function)`是完成特定任务的独立程序代码单元。
语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言中的函数、子程序、
过程作用相同，但是细节上略有不同。

* 一些函数执行某些动作，如printf()把数据打印到屏幕上；

* 一些函数找出一个值供程序使用，如strlen()把指定字符串的长度返回给程序。


#### 为什么要使用函数

* 首先，使用函数可以省去编写重复代码的苦差。
* 其次，使用函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、
完善。


#### 分析程序
函数原型(function prototype)告诉编译器函数的类型;
函数调用(function call)表明在此处执行函数;
函数定义(function definition)明确地指定函数要做什么。

main: 主调函数(calling function)


#### 定义带形式参数的函数
函数定义从下面的ANSI C风格的函数头开始：
void show_n_char(char ch, int num);
该行告知编译器show_n_char()使用两个参数ch和num.
这两个变量被称为`形式参数(formal argument,最近的标准推荐使用formal parameter),
简称形参。
形式参数也是局部变量，属该函数私有。


#### 声明带形式参数函数的原型
在使用函数之前，要用ANSI C形式声明函数原型：
```c
void show_n_char(char ch, int num);
```
也可以省略变量名：
```c
void show_n_char(char, int);
```
在原型中使用变量名并没有实际创建变量，char仅代表一个char类型的变量

ASIC也接受过去的声明函数形式，即圆括号内没有参数列表：
```c
void show_n_char();
```
这种形式最终会从标准中剔除。


#### 返回值
```c
int what_if(int n)
{
	double z = 100.0 / (double) n;
	return z; 
}
```
`
虽然在what_if()函数中赋值给z的值是1.5625,但是return语句返回确实int类型的值1.
使用return 语句的另一个作用是，终止函数并把控制返回给主调用函数的下一条语句。
`
函数类型 指的是函数返回值的类型。


#### 函数类型
ANSI C标准库中，函数被分成多个系列，每一系列都有各自的头文件。这些头文件中除
了其他内容，还包含了本系列所有函数的声明。例如，stdio.h头文件包含了标准I/O库
函数(如，printf()和scanf())的声明。math.h头文件包含了各种数字函数的声明。
如： double sqrt(double);


#### 无参数和未指定参数
一些函数接受(如， printf()和scanf())许多参数。
可以使用下面的原型：
```c
int printf(const char *, ...);
```
这种原型表明，第1个参数是一个字符串，可能还有其他未指定的参数。


#### 函数原型的优点
函数原型是C语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或
疏漏。
把整数个函数定义放在第1次调用该函数之前，也有相同的效果。此时，函数定义也相当于函数
原型。
```c
// 下面这行代码既是函数定义，也是函数原型
int imax(int a, int b) { return a > b ? a : b; }
int main()
{
	int x, z;
	...
	z = imax( x, 50);
	...
	return 0;
}

```


#### 递归
C允许函数调用它自已，这种调用过程称为`递归(recursion)`.


#### 尾递归
最简单的递归是把递归调用置于函数的末尾，即正好在return语句之前。这种形式的递归被
称为`尾递归(tail recursion)`,因为递归调用在函数的末尾。尾递归是最简单的递归形式，
因为它相当于循环。


#### 递归和循环的选择
一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的内存更多，
而且每次递归调用都会把创建的一组新变量放在栈中。
递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的
执行速度较慢。


#### 递归和倒序计算
递归在处理倒序时非常方便(在解决这类问题中，递归比循环简单).


#### 所有的C函数皆平等
程序中的每个C函数与其他函数都有是平等的。每个函数都可以调用其他函数，或被其他函数
调用。
main()函数是否与其他函数不同？是的，main()的确有点特殊。当main()与程序中的其他函数
放在一起时，最开始执行的是main()函数中的第1条语句，但是这也是局限之处。main()也可以
被自已或其他函数递归调用——尽管很少这样做。


#### 编译多源代码文件的程序
使用多个函数最简单的方法是把它们都有放在同一个文件中，然后像编译只有一个函数的文件那
样编译该文件即可。其他方法因操作系统而异

UNIX:
编译两个文件并生成一个名为a.out的可执行文件：
cc file1.c file2.c [ -o a.out ]
另外，还生成两个名为file1.o和file2.o的目标文件。


LINUX:
编译两个C文件为一个名为a.out的可执行文件：
gcc file1.c file2.c [ -o a.out ]
另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c,而file2.c不变，
可以使用以下命令编译第1个文件，并与第2文件的目标代码合并:
gcc file1.c file2.o

DOS命令行编译器:
绝大多数DOS命令行编译器的工作原理和UNIX的cc命令类似，只不过使用不同的名称而已。其中
一个区别是，对象文件的扩展名是.obj,而不是.o.一些编译器生成的不是目标代码文件，而是汇
编语言或其他特殊代码的中间文件。


#### 使用头文件
如果把main()放在第1个文件中，把函数定义放在第2个文件中，那么第1个文件仍然要使用函数原型。
把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C标准库就是这样做的，
例如，把I/O函数原型放在stdio.h中，把数字函数原型放在math.h中。

另外，程序中经常用C预处理器定义符号常量。这种定义只储存了那些包含#define指令的文件。如
果把程序的一个函数放进一个独立的文件中，你也可以使用#define指令访问每个文件。最直接的方法
是在每个文件中再次输入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果修改
了#define定义的值，就必须在每个文件中修改。更好的做法是，把#define指令放进头文件，然后
在每个源文件中使用#include指令包含该文件即可。

`总之，把函数原型和已定义的字符常量放在头文件中是一个良好的习惯。`


#### 函数原型的作用
ANSI C提供了一个强大的工具——函数原型，允许编译器验证函数调用中使用的参数个数和类型是否正确。
