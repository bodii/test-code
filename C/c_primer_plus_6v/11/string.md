#### 表示字符串和字符串I/O
和printf()函数一样，puts()函数也属于strio.h系列的输入/输出函数。但是，
与printf()不同的是， puts()函数只显示字符串，而且自动在显示的字符串末
尾加上换行符。

定义字符串的方式：
字符串常量、char类型数组、指向char的指针


#### 字符串字面量(字符串常量)
用双引号括起来的内容称为`字符串字面量(string literal)`，也叫作`字符串常量
(string constant)`。双引号中的字符和编译器自动加入末尾的\0字符。

从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其
视为串联起来的字符串字面量，如：
```c
char greeting[50] = "Hello, and"" how are"" you"
					" today!";

// 等价:
char greeting[50] = "Hello, and how are you today!";
```

字符串常量属于`静态存储类别(static storage class)`,这说明如果在函数中使用字
符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多
次。用双引号括起来的内容被视为指向该字符串储存位置的指针。


#### 字符串数组和初始化
```c
const char m1[40] = "Limit yourself to me line's worth.";
```
const表明不会更改这个字符串。
等价于：
```c
const char m1[40] = {
	'L', 'i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l',
	'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ', 'l', 'i', 'n', 'e',
	'\'', 's', ' ', 'w', 'o', 'r', 't', 'h', '.', '\0'
};
```
注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组。
在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符).
所有未被使用的元素都被自动初始化为0(在这里的0指的是char形式的空字符(\0))

省略数组初始化声明中的大小，编译器会自动计算数组的大小：
```c
const char m2[] = "If you can't think of anything, fake it.";
```

数组的大小必须是整型常量，包括由整型常量组成的表达式。
```c
int n = 8;
char cookies[1];  // 有效
char cakes[2 + 5]; // 有效，数组大小是整型常量表达式
char pies[2*sizeof(long double) + 1]; // 有效
char crumbs[n];    // 在C99标准之前无效，C99标准之后这种数组是变长数组
```
字符数组名和其他数组名一样，是该数组首元素的地址。

还可以使用指针表示法创建字符串：
```c
const char * pt1 = "Something is pointing at me.";
// 等价
const char ar1[] = "Something is pointing at me.";
```

#### 数组和指针
数组形式和指针形式有何不同?
> 字符串储存在静态存储区(static memory)中，但是，程序在开始运行时才会为该
数组分配内存。此时， 才将字符串拷贝到数组中。注意，此时字符串有两个副本
。一个是在静态内存中的字符串字面量，另一个是储存在ar1数组中的字符串。

此后，编译器便把数组名为ar1识别为该数组首元素地址(&ar1[0])的别名。这里关键
要理解，在数组形式中，ar1是地址常量。不能更改ar1,如果改变了ar1,则意味着改变
了数组的存储位置(即地址).可以进行类似ar1+1这样的操作，标识数组的下一个元素。
但是不允许进行++ar1这样的操作。递增运算符只能用于变量名前(或概括地说，只能用
于可修改的左值），不能用于常量。

指针形式(*pt1)也使用得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦
开始执行程序，它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在指针变量
中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算
符。例如，++pt1将指向第2个字符.
> 总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址
拷贝给指针。


