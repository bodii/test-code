#### 字符串输入
如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数
获取该字符串。


#### 分配空间
要做的第1件事是分配空间，以储存稍后读入的字符串。
在声明时显式指明数组的大小：
```c
char name[81];
```


#### 不幸的gets()函数
在读取字符串时，scanf()和转换说明%s只能读取一个单词。可是在程序中经常要读取
一整行输入，而不仅仅是一个单词。gets()函数简单易用，它读取整行输入，直至遇到
换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成
为一个C字符串。它经常和puts()函数配对使用，该函数用于显示字符串，并在末尾添加
换行符。

出于安全考虑，C11标准委员会，直接从标准中废除了gets()函数。


#### gets()的替代品
过去通常用fgets()代替gets(). 
C11标准新增的gets_s()函数也可代替gets().该函数gets()函数更接近，而且可以替换
现有代码中的gets().但是，它是stdio.h输入/输出函数系列中的可选扩展，所以支持C11
的编译器也不一定支持它。

1. fgets()函数(和fputs())
	fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于
	处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别：
	
	* fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n,那么fgets()
	将读入n-1个字符，或者读到遇到的第一个换行符为止。

	* 如果fgets()读到一个换行符，会把它储存在字符串中，这点与gets()不同，gets()会
	丢弃换行符。

	* fgets()函数的第3个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin(
	标准输入)作为参数，该标识符定义在stdio.h中.

> 因为fgets()函数把换行符放在字符串的末尾(假设输入行不溢出),通常要与fputs()函数(
	和puts()类似)配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参
	数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout(标准输出)作为参数。


> fputs()函数返回指向char的指针。如果一切进行顺利，该函数返回的地址与传入的第1个参
	数相同。但是，如果函数读到文件结尾，它将返回一个特殊的指针：`空指针(null pointer)`
	该指针保证不会指向有效的数据，所以可用于标识这种特殊情况。在代码中，可以用数字0代
	替，不过在C语言中用宏NULL来代替更常见（如果在读入数据时出现某些错误，该函数也返回
	NULL)


系统使用缓冲的I/O.这意味着用户在按下Return键之前，输入都有被储存在临时存储区（即，缓冲区)
中。按下Return键就在输入中增加了一个换行符，并把整行输入发送给fgets().对于输出，fputs()
把字符发送给另一个缓冲区，当发送换行符时，缓冲区中的内容被发送至屏幕上。

fgets()储存换行符有好处也有坏处。坏处是你可能并不想把换行符储存在字符串中，这样的换行符
会带来一些麻烦。好处是对于储存的字符串而言，检查末尾是否有换行符可以判断是否读取了一整行。
如果不是一整行，要妥善处理一行中剩下的字符。


如何处理换行符？一个方法是在已储存的字符串中查找换行符，并将其替换成空字符：
```c
while (words[i] != '\n') 
	i++;
words[i] = '\0';
```
如果目标数组装不下一整行输入，就丢弃那些多出的字符:
```c
while (getchar() !='\n')  // 读取但不储存输入，包括\n
	continue;
```

> 空字符(或'\0')是用于标记C字符串末尾的字符，其对应的字符编码是0.由于其他字符的编码不可能是0,
所以不可能是字符串的一部分。
> 空指针(或NULL)有一个值，该值不会与任何数据的有效地址对应。通常，函数使用它返回一个有效地
址表示某些特殊情况发生，例如遇到文件结尾或未能按预期执行.
> 空字符是整数类型，而空指针是指针类型。两者有时容易混淆的原因是：它们都可以用数值0来表示。
但是，从概念上看，两者是不同类型的0.另外，空字符是一个字符，占1字符;而空指针是一个地址，通常
占4字节。


#### gets_s()函数
C11新增的gets_s函数(可选)和fgets()类似，用一个参数限制读入的字符数。

gets_s与fgets()的区别:
* gets_s()只从标准输入中读取数据，所以不需要第3个参数。
* gets_s()读到换行符，会丢弃它而不是储存它。
* gets_s()读到最大字符数都有没有读到换行符，会执行以下几步:
	- 首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，
	然后返回空指针。
	- 接着，调用依赖实现的"处理函数"(或你选择的其他函数),可能会中止或退出程序。 
这2个特性说明，只要输入行未超过最大字符数，gets_s()和gets()几乎一样，完全可以用gets_s()替换
gets().
当输入与预期不符时，gets_s()完全没有fgets()函数方便、灵活。也许这也是gets_s()只作为C库的可选
扩展的原因之一。鉴于此，fgets()通常是处理类似情况的最佳选择。


#### s_gets()函数
```c
char * s_gets(char * st, int n)
{
    char * ret_val;
    int i = 0;

    ret_val = fgets(st, n, stdin);
    if (ret_val) // 即，ret_val != NULL
    {
        while (st[i] != '\n' && st[i] != '\0')
            i++;
        if (st[i] == '\n')
            st[i] = '\0';
        else
            while (getchar() != '\n')
                continue;
    }

    return ret_val;
}

```
s_gets()函数并不完美，它最严重的缺陷是遇到不合适的输入时毫无反应。它丢弃多余的字符时，既
不通知程序也不告知用户。但是，用来替换前面程序例中的gets()足够了。


#### scanf()函数
scanf()和gets()或fgets()的区别在于它们如何确定字符串的末尾:scanf()更像是"获取单词"函数，而
不是"获取字符中"函数;如果预留的存储区装得下输入行, gets()和fgets()会读取第1个换行符之前所有
的字符。scanf()函数有两种方法确定输入结束。无论哪种方法，都从第1个非空白字符作为字符串的开始。
如果使用%s转换说明，以下一个空白字符(空行、空格、制表符或换行符)作为字符串的结束(字符串不包括
空白字符).如果指定的字段宽度，如%10s,那么scanf()将读取10个字符或读到第1个空白字符停止。

fgets()读取从键盘输入的的数据更合适。
scanf()的典型用法是读取并转换混合数据类型为某种标准形式。如，一种工具名、库存量和单价。
scanf()和gets类似，也存在一些潜在的缺点。如果输入行的内容过长，scanf()也会导致数据溢出。不过，
在%s转换说明中使用字段宽度可防止溢出。


#### 字符串的输出
C有3个标准库函数用于打印字符串：put()、fputs()和printf().


#### fputs()函数
fputs()函数是puts()针对文件定制的版本。它们的区别：
* fputs()函数的第2个参数指明要写入数据的文件。如果要打印在显示器上，可以用定义在stdio.h中的
stdout(标准输出)作为该参数。
* 与puts()不同，fputs()不会在输出的末尾添加换行符。
gets()丢弃输入中的换行符，但是puts()在输出中添加换行符。另一方面，fgets()保留输入中的换行符，
fputs()不在输出中添加换行符。
如果gets()读到文件结尾会返回空指针。对空指针求值为0(即为假),这样便可结束循环。
可以这样写:
```c
char line[81];
while (gets(line))  // 与while(gets(line) != NULL) 相同
	puts(line);

// 或
char line[81];
while (fgets(line, 81, stdin))
	fputs(line, stdout);
```
puts()应该与gets()配对使用，fputs应与fgets()配对使用。
gets()已被废弃, 不建议使用。

相同的输出，printf()的形式更复杂些，需要输入更多代码，而且计算机执行的时间也更长.


#### 自定义输入/输出函数
```c
#include <stdio.h>

void put(const char * string)  /* 不会改变字符串 */
{
    while (*string != '\0')
        putchar(*string++);
}
```
用数组表示法编写这个函数：
```c
int i = 0;
while (string[i] != '\0')
	putchar(string[i++]);
```
还可以使用这种形式:
```c
while (*string)
```
当string指向空字符时，*string的值是0.


