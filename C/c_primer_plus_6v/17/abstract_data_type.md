#### 抽象数据类型(ADT)
> 类型特指两类信息: 属性和操作。
例如，int类型的属性是它代表一个整数值，因此它共享整数的属性。允许对int类型时行算术操作是：
改变int类型值的符号、两个int类型值相加、相减、相乘、相除、求模。
当声明一个int类型的变量时，就表明了只能对该变量进行这些操作。

注意 整数属性
C的int类型背后是一个更抽象的整数概念。
假设要定义一个新的数据类型。首先，必须提供储存数据的方法，例如设计一个结构。其次，必须提供
操控数据的方法。

计算机科学领域已开发了一种定义新类型的好方法，用3个步骤完成从抽象到具体的过程。

1. 提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。
这种正式的抽象描述被称为抽象数据类型(ADT).

2. 开发一个实现ADT的编程接口。也就是说，指明如何储存数据和执行所需要操作的函数。例如在C中，可
以提供结构定义和操控该结构的函数原型。这些作用于用户定义类型的函数相当于作用于C基本类型的内置
运算符。需要使用该新类型的程序员可以使用这个接口进行编程。

3. 编写代码实现接口。


#### 建立抽象
#### 建立接口
```c
#define TSIZE 45  /* 储存电影名的数组大小 */
struct film
{
	char title[TSIZE];
	int rating;
};
typedef struct film Item;
```
然后，就可以在定义的其余部分使用Item类型。如果以后需要其他数据形式的链表，可以重新定义Item类型，
不必更改其余的接口定义。
定义了Item之后，现在必须确定如何储存这种类型的项。
```c
typedef struct node
{
	Item item;
	struct node * next;
} Node;
typedef Node * List;
```
在链表的实现中，每一个链节叫作节占(node)。每个节点包含形成链表内容的信息和指向下一个节点的指针。
最后，为了管理链表，还需要一个指向链表开始处的指针,我们使用typedef把List作为该类型的指针名:
```c
List movies;
```
创建了该链表所需类型的指针movies。

还可以添加一个变量记录项数:
```c
typedef struct list
{
	Node * head;   /* 指向链表头的指针 */
	int size;      /* 链表中的项数 */
} List;      /* List的另一种定义 */
```
现在，我们还是使用List类型的第1种定义。这里要着重理解下面的声明创建了一个链表，而不是一个指向节点
的指针或一个结构：
```c
List movies;
```
movies代表的确切数据应该是接口层次不可见的实现细节。
例如，程序启动后应该把头指针初始化为NULL。但是，不要使用下面这样的代码:
```c
movies = NULL;
```
应该这样初始化:
```c
movies.next = NULL;
movies.size = 0;
```
使用List的人都不用担心这些细节，只要能使用下面的代码就行:
```c
InitializeList(movies);
```
使用该类型，只需用InitializeList()函数来初始化链表，不必了解List类型变量的实现细节。
数据隐藏是一种从编程的更高层次隐藏数据表示细节的艺术。


为了指导用户使用，可以在函数原型前面提供以下注释:
```c
/* 操作: 初始化一个链表  */
/* 前提条件: plist指向一个链表 */
/* 后置条件: 该链表初始化为空 */
void InitializeList(List * plist);
```

C语言把所有类型和函数的信息集合成一个软件包的方法是: 把类型定义和函数原型(包括前提
条件和后置条件注释)放在一个头文件中。
在头文件中，把组成函数名的每个单词的首字母大写，以这种方式表明这些函数是接口包的一
部分。



