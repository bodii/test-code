#### 分配内存：malloc()和free()
静态数据在程序载入内存时分配，而自动数据在程序执行块时分配，并在程序离开该
块时销毁。

C能做的不止这些。可以在程序运行时分配更多的内存。主要的工具是malloc()函数，
该函数接受一个参数：所需的内存字节数。malloc()函数会找到合适的空闲内存块，这
样的内存是匿名的。也就是说，malloc()分配内存，但是不会为其赋名。然而，它确实
返回动态内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访
问这块内存。因为char表示1字节，malloc()的返回类型通常被定义为指向char的指针。
然而，从ANSI C标准开始，C使用一个新的类型：指向void的指针。
该类型相当于一个"通用指针".malloc()函数可用于返回指向数组的指针、指向结构的指
针等，所以通常该函数的返回值会被强制转换为匹配的类型。在ANSI C中，应该坚持使用
强制类型转换，提高代码的可读性。然而，把指向void的指针赋给任意类型的指针完全不
用考虑类型匹配的问题。如果malloc()分配内存失败，将返回空指针.

用malloc()创建一个数组。除了用malloc()在程序运行时请求一块内存，还需要一个指针
记录这块内存的位置：
```c
double * ptd;

ptd = (double *) malloc(30 * sizeof(double));
```
以上代码为30个double类型的值请求内存空间，并设置ptd指向该位置。
可以使用表达式ptd[0]访问该块的首元素，ptd[1]访问第2个元素。

3种创建数组的方法：

1. 声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存
或自动内存创建这种数组

2. 声明变长数组（C99新增），用变量表达式表示数组的维度，用数组名访问数组的元素。
具有这种特性的数组只能在自动内存中创建。

3. 声明一个指针，调用malloc(),将其返回值赋给指针，使用指针访问数组的元素。该指针可以
是静态的或自动的。

使用第2种和第3种方法可以创建`动态数组(dynamic array)`.这种数组和普通数组不同，可以在
程序运行时选择数组的大小和分配内存。
```c
double item[n];  /* C99之前：n不允许是变量 */
// 但是，可以这样做
ptd = (double *) malloc(n * sizeof(double));  /* 可以 */
```

通常，malloc()要与free()配套使用。
free()函数的参数是之前malloc()返回的地址，该函数释放之前malloc()分配的内存。因此，动态
分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止。
设想malloc()和free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用free
()把内存归内存池中，这样便可重复使用这些内存。free()的参数应该是一个指针，指向由malloc
()分配的一块内存。不能用free()释放通过其他方式（如，声明一个数组)分配的内存。

malloc()和free()的原型都有在stdlib.h头文件中。

使用malloc(),程序可以在运行时才确定数组大小。

如果内存分配失败，可以调用exit()(在stdlib.h).
EXIT_FAILURE的值也被定义在stdlib.h中。

EXIT_SUCCESS(或者，相当于0)表示普通的程序结束
EXIT_FAILURE表示程序异常中止.一些操作系统（包括UNIX、Linux和Windows)还接受一些表示其他
运行错误的整数值。


在C中，不一定要使用强制类型转换(double *), 但是在C++中必须使用，所以，使用强制类型转换
更容易把C程序转换为C++程序。

free()函数位于程序的末尾，它释放了malloc()函数分配的内存。free()函数只释放其参数指向的
内存块。一些操作系统在程序结束时会自动释放动态分配的内存，但是有些系统不会。为保险起见，
请使用free().


#### free()的重要性
```c
int main()
{
	double glad[2000];
	int i;

	for (i = 0; i < 1000; i++)
		gobble(glad, 2000);
}

void gobble(double ar[], int n)
{
	double * temp = (double *) malloc(n * sizeof(double));
		/* free(temp);  // 假设忘记使用free() */
}
```
第1次调用gobble()时，创建了指针temp,并调用malloc()分配了16000字节的内存(double为8字节).
函数结束时，作为自动变量的指针tmep也会消失，但是它所指向的16000字节的内存却仍然存在。
第2次调用gobble()时，它又创建了指针temp,并调用malloc()分配了16000字节的内存。第1次分配
的16000字节内存已不可用，但仍在内存中。
循环1000次，所以在循环结束时，内存池中有1600万字节被占用。实际上，也许在循环结束之前就
已耗尽所有的内存。
这类问题被称为`内存泄漏(memory leak)`.在函数末尾处调用free()函数可避免这类问题发生。


#### calloc()函数
分配内存还可以使用calloc(),
```c
long * newmem;
newmem = (long *) calloc(100, sizeof(long));
```
和malloc()类似，在ANSI之前，calloc()也返回指向char的指针;在ANSI之后，返回指向void的指针。
如果要储存不同的类型，应使用强制类型转换运算符。
calloc()函数接受两个无符号整数作为参数(ANSI规定是size_t类型）。
第1个参数是所需的存储单元数量，
第2个参数是存储单元的大小(以字节为单位).
在该例中，long为4字节，所以，前面的代码创建了100个4字节的存储单元，总共400字节。
用sizeof(long)而不是4,提高了代码的可移植性。这样，在其他long不是4字节的系统中也能正常工作。
calloc()函数还有一个特性：它把块中的所有位都设置为0.
free()函数也可用于释放calloc()函数分配的内存。


#### 动态内存分配和变长数组
变长数组(VLA)和调用malloc()在功能上有些重合。
不同的是，变长数组是自动存储类型。因此，程序在离开变长数组定义所在的块时，变长数组占用的内存
空间会被自动释放，不必使用free().另一方面，用malloc()创建的数组不必局限在一个函数内访问。
例如以，被调函数创建一个数组并返回指针，供主调函数访问，然后主调函数在末尾调用free()释放之前
被调函数分配的内存。另外，free()所用的指针变量可以与malloc()的指针变量不同，但是两个指针必须
储存相同的地址。但是，不能释放同一块内存两次。

对多维数组而言，使用变长数组更方便。当然，也可以用malloc()创建二维数组，但是语法比较繁琐。
```c
int n = 5;
int m = 6;
int ar2[n][m];  // nxm的变长数组（VLA）
int (* p2)[6]; // C99之前的写法
int (* p3)[m];  // 要求支持变长数组
p2 = (int (*)[6]) malloc(n * 6 * sizeof(int));  // nx6数组
p3 = (int (*)[m]) malloc(n * m * sizeof(int));  // nxm数组
ar2[1][2] = p2[1][2] = 12;
```


#### 存储类别和动态内存分配
可以认为程序把可用的内存分为3部分：一部分供具有外部链接、内部链接和无链接的静态变量使用;
一部分供自动变量使用;一部分供动态内存分配。

静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可访问储存在该部分的数据。该
类别的变量在程序开始执行时被创建，在程序结束时被销毁。

自动存储类别的变量在程序进入变量定义所在块时存在，在程序离开块时消失。因此，随着程序调用
函数和函数结束，自动变量所用的内存数量也相应地增加和减少。这部分的内存通常作为栈来处理，
这意味着新创建的变量按顺序加入内存，然后以相反的顺序销毁。

动态分配的内存在调用malloc()或相关函数时存在，在调用free()后释放，这部分的内存由程序员管理
，而不是一套规则。所以内存块可以在一个函数中创建，在另一个函数中销毁。正是因为这样，这部分
的内存用于动态内存分配会支离破碎。也就是说，未使用的内存块分散在已使用的内存块之间。另外，
使用动态内存通常比使用栈内存慢。

总而言之，程序把静态对象、自动对象和动态分配的对象储存在不同的区域。


#### ANSI C类型限定符
C90新增了两个属性：
恒常性(constancy) 和 易变性(volatility).
这两个属性可以分别用关键字const和volatile来声明，以这两个关键字创建的类型是限定类型(qualified
type).
C99标准新增了第3个限定符：restrict,用于提高编译器优化。
C11标准新增了第4个限定符：_Atomic.
C11提供一个可选库，由stdatomic.h管理，以支持并发程序设计，而且_Atomic是可选支持项。

C99为类型限定符增加了一个新属性： 它现在是幂等的(idempotent)!其实意思是可以在一条声明中多次使用
同一限定符，多余的限定符将被忽略：
```c
const const const int n = 6; // 与const int n = 6; 相同
```
有了这个新属性，就可以编写类似的代码：
```c
typedef const int zip;
const zip q = 8;
```


#### const类型限定符
```c
const float * pf;    /* pf 指向一个float类型的const值 */

float * const pt;    /* pt 是一个const指针 */

const float * const ptr;  /* ptr既不能指向另外，它所指向的值也不能改变 */

float const * pfc;    /* 与const float * pfc 相同 */
```

可以同时使用const和volatile限定一个值：
```c
volatile const int loc;
cosnt volatile int * ploc;
```


#### restrict类型限定符
restrict关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问
数组对象的唯一且初始的方式。
```c
int ar[10];
int * restrict restar = (int *) malloc(10 * sizeof(int));
int * par = ar;
```
这里，指针restar是访问由malloc()所分配内存的唯一且初始的方式。因此，可以用restrict关键字
限定它。而指针par既不是访问ar数组中数据的初始方式，也不是唯一方式。所以不用把它设置为restrict

restric关键字有两个读者。
一个是编译器，该关键字告知编译器可以自由假定一些优化方案
另一个读者是用户，该关键字告知用户要使用满足restrict要求的参数。


C提供多种管理内存的模型。除了熟悉这些模型外，还要学会如何选择不同的类别。大多数情况下，最好
选择自动变量。如果要使用其他类别，应该有充分的理由。通常，使用自动变量、函数形参和返回值进
行函数间的通信比使用全局变量安全。但是，保持不变的数据适合用全局变量。
